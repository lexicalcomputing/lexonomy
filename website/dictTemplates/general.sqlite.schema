CREATE TABLE configs (id TEXT PRIMARY KEY, json TEXT);
INSERT INTO configs VALUES('ident','{	"title": "Simple Dictionary",	"blurb": "This is a simple dictionary of English, with only three entries, intended to demonstrate the capabilities of Lexonomy.","lang":"English"}');
INSERT INTO configs VALUES('publico','{	"public": false}');
INSERT INTO configs VALUES('kex','{}');
INSERT INTO configs VALUES('titling','{"headword": "entry", "headwordSorting": "entry"}');
INSERT INTO configs VALUES('xampl','{"container": "example"}');
INSERT INTO configs VALUES('entry_count', 0);
INSERT INTO configs VALUES('completed_entries', 0);
CREATE TABLE searchables (id INTEGER PRIMARY KEY AUTOINCREMENT, entry_id INTEGER REFERENCES entries (id) ON DELETE CASCADE, txt TEXT, level INTEGER);
CREATE TABLE history (
    id             INTEGER  PRIMARY KEY AUTOINCREMENT,
    entry_id       INTEGER,
    [action]       TEXT,
    [when]         DATETIME,
    email          TEXT,
    nvh            TEXT,
    historiography TEXT
);
CREATE TABLE sub (id INTEGER PRIMARY KEY AUTOINCREMENT, parent_id INTEGER REFERENCES entries (id) ON DELETE CASCADE, child_id INTEGER REFERENCES entries (id) ON DELETE CASCADE);
CREATE TABLE entries (id INTEGER PRIMARY KEY AUTOINCREMENT, doctype TEXT, nvh TEXT, json JSON, title TEXT, sortkey TEXT, needs_resave BOOLEAN DEFAULT (0), needs_refresh BOOLEAN DEFAULT (0), needs_refac BOOLEAN DEFAULT (0));
CREATE TABLE linkables (id INTEGER PRIMARY KEY AUTOINCREMENT, entry_id INTEGER REFERENCES entries (id) ON DELETE CASCADE, txt TEXT, element TEXT, preview TEXT);
CREATE INDEX search ON searchables (txt, level);
CREATE INDEX history_by_entry_id ON history (
    entry_id,
    "when"
);
CREATE INDEX history_by_email ON history (
    email,
    "when"
);
CREATE INDEX history_by_when ON history (
    "when"
);
CREATE INDEX history_by_action ON history (
    "action",
    "when"
);
CREATE INDEX sortkey ON entries (sortkey);
CREATE INDEX needs_re ON entries (needs_resave, needs_refresh, needs_refac);
