<dict-config-ske>
   <loading-overlay if={state.isLoading || state.isSaving}/>
   <h1>Sketch Engine connection</h1>
   <div if={state.showMissingHeadwordWarning}
         class="section">
      <div class="message messageInfo">
         please <a href="#/{dictData.dictId}/config/titling">select headword</a> in Config-Headword first
      </div>
   </div>
   <div if={ !authData.ske_username || !authData.ske_apiKey || authData.ske_apiKey == "" || authData.ske_username == "" }
         class="message messageInfo">
      Please setup your Sketch Engine account in your <a href="#/user-profile">profile</a> settings to be able to select a corpus.
   </div>
   <template if={!state.showMissingHeadwordWarning}>
      <template if={ authData.ske_username && authData.ske_apiKey && authData.ske_username != "" && authData.ske_apiKey != "" }>
         <div class="row">
            <div class="input-field">
               <input data-selected-corpus={ state.data.kex.corpus }
                     type="text"
                     id="kex_corpus"
                     placeholder="Type to search in the list of corpora"
                     class="autocomplete"
                     placeholder="Retrieving available corpora from Sketch Engine, please wait...">
               <label for="kex_corpus">Corpus name</label>
               <span class="helper-text">Select a Sketch Engine corpus from the list of corpora available to you.</span>
               <span class="helper-text"
                     id="corpusInfo"
                     style="display: none"></span>
            </div>
         </div>
         <div class="row">
            <div class="input-field">
               <input value={ state.data.kex.concquery}
                     id="kex_concquery"
                     type="text" />
               <label for="kex_concquery">Concordance query</label>
               <span class="helper-text">The CQL query that will be used to obtain concordance from Sketch Engine. You can use placeholders for elements in the form of '%(element)', e.g. '[lemma="%(headword)"]'. If left empty the 'simple' query type will be used as configured for the respective corpus. Please note that you cannot use CQL syntax with default attribute because it is not specified.</span>
            </div>
         </div>
         <div class="row">
            <div class="input-field">
               <input value={ state.data.kex.concsampling}
                     id="kex_concsampling"
                     type="number" />
               <label for="kex_concsampling">Sample size</label>
               <span class="helper-text">Whether to apply automatic sampling of the concordance. Any non-zero value means to automatically create a random sample of that size.</span>
            </div>
         </div>
         <div class="row">
            <div class="input-field">
               <element-select id="kex_searchElements"
                     riot-value={state.data.kex.searchElements}
                     multiple={true}/>
               <label for="kex_searchElements">Additional search elements</label>
               <span class="helper-text">You can select any textual elements here whose content you would like to search for in Sketch Engine. A menu will be displayed next to all these elements like for the root entry element.</span>
            </div>
         </div>
      </template>
      <div class="row">
         <h2>Examples</h2>
      </div>
      <div class="row">
         <div class="input-field">
            <element-select id="xampl_container"
                  riot-value={state.data.xampl.container}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="xampl_container">Example container</label>
            <span class="helper-text">Select the element which should wrap each individual example. When you pull example sentences automatically from a corpus, Lexonomy will insert one of these elements for each example sentence.</span>
         </div>
      </div>
      <!--div class="row">
         <div class="input-field">
            <textarea id="xampl_template"
                  class="materialize-textarea"
                  placeholder="XML template">{ state.data.xampl.template }</textarea>
            <label for="xampl_template">XML template</label>
            <span class="helper-text">This is the XML that will be inserted into your entries with each corpus example. The actual text will be where the placeholder <tt>$text</tt> is.</span>
         </div>
      </div-->
      <!--div class="row">
         <div class="input-field">
            <element-select id="xampl_markup"
                  riot-value={state.data.xampl.markup}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="xampl_markup">Headword mark-up</label>
            <span class="helper-text">Select the element which should mark up the headword in inserted corpus examples. This setting is optional: if you make no selection, corpus examples will be inserted without mark-up.</span>
         </div>
      </div-->
      <div class="row">
         <h2>Collocations</h2>
      </div>
      <div class="row">
         <div class="input-field">
            <element-select id="collx_container"
                  riot-value={state.data.collx.container}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="collx_container">Collocation container</label>
            <span class="helper-text">Select the element which should wrap each collocation (the collocate plus any other data). When you pull collocations automatically from a corpus, Lexonomy will insert one of these elements for each collocation.</span>
         </div>
      </div>
      <!--div class="row">
         <div class="input-field">
            <textarea id="collx_template"
                  class="materialize-textarea"
                  placeholder="XML template">{ state.data.collx.template }</textarea>
            <label for="collx_template">XML template</label>
            <span class="helper-text">This is the XML that will be inserted into your entries with each collocation. The actual text will be where the placeholder <tt>$text</tt> is.</span>
         </div>
      </div-->
      <div class="row">
         <h2>Thesaurus items</h2>
      </div>
      <div class="row">
         <div class="input-field">
            <element-select id="thes_container"
                  riot-value={state.data.thes.container}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="thes_container">Thesaurus item container</label>
            <span class="helper-text">Select the element which should wrap each individual thesaurus item (a word). When you pull thesaurus items automatically from a corpus, Lexonomy will insert one of these elements for each thesaurus item.</span>
         </div>
      </div>
      <!--div class="row">
         <div class="input-field">
            <textarea id="thes_template"
                  class="materialize-textarea"
                  placeholder="XML template">{ state.data.thes.template }</textarea>
            <label for="thes_template">XML template</label>
            <span class="helper-text">This is the XML that will be inserted into your entries with each thesaurus item. The actual text will be where the placeholder <tt>$text</tt> is.</span>
         </div>
      </div-->
      <div class="row">
         <h2>Definitions</h2>
      </div>
      <div class="row">
         <div class="input-field">
            <element-select id="defo_container"
                  riot-value={state.data.defo.container}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="defo_container">Definition container</label>
            <span class="helper-text">Select the element which should wrap each definition. When you pull definitions automatically from a corpus, Lexonomy will insert one of these elements for each definition.</span>
         </div>
      </div>
      <!--div class="row">
         <div class="input-field">
            <textarea id="defo_template"
                  class="materialize-textarea"
                  placeholder="XML template">{ state.data.defo.template }</textarea>
            <label for="defo_template">XML template</label>
            <span class="helper-text">This is the XML that will be inserted into your entries with each definition. The actual text will be where the placeholder <tt>$text</tt> is.</span>
         </div>
      </div-->
   </template>
   <dict-config-buttons save-data={saveData}
         show-save={!state.showMissingHeadwordWarning}></dict-config-buttons>

   <script>
      export default {
         state: {
            isLoading: true,
            isSaving: false,
            showMissingHeadwordWarning: false,
            data: {
               kex: {
                  concsampling: 0,
                  searchElements: []
               },
               xampl: {container: "", markup: ""},
               collx: {container: ""},
               defo: {container: ""},
               thes: {container: ""},
            }
         },

         onBeforeMount(){
            if(!this.dictData.config.titling.headword){
               this.state.showMissingHeadwordWarning = true
               this.state.isLoading = false
            }
         },

         onMounted(){
            if(!this.state.showMissingHeadwordWarning){
               this.store.loadDictionaryConfig("ske")
                     .done(response => {
                        this.state.data = response.content
                        this.state.data.kex.concsampling = this.state.data.kex.concsampling || 0
                        this.state.data.kex.searchElements = this.state.data.kex.searchElements || []
                        this.store.skeLoadCorpora()
                              .done(response => {
                                 let corpusList = response.data.map(corpus => {
                                    let size = corpus.sizes ? `, ${(corpus.sizes.tokencount / 1000000).toFixed(2)}M tokens` : ""
                                    return {
                                       value: corpus.corpname,
                                       label: corpus.name,
                                       info: `${corpus.language_name}${size}`
                                    }
                                 })
                                 $("#kex_corpus").autocomplete({
                                    data: corpusList,
                                    onAutocomplete: corpus => {
                                       $("#kex_corpus").attr("corpname", corpus.value)
                                       this.refreshCorpusNote(corpus)
                                    }
                                 })
                                 let selectedCorpus = this.state.data.kex.corpus && corpusList.find(corpus => corpus.value == this.state.data.kex.corpus)
                                 if(selectedCorpus){
                                    $("#kex_corpus").val(selectedCorpus.label)
                                          .attr("corpname", selectedCorpus.value)
                                    this.refreshCorpusNote(selectedCorpus)
                                 }
                              })
                              .always(() => {
                                 this.update({isLoading: false})
                              })
                     })
                     .fail(() => {
                        this.update({isLoading: false})
                     })
                     .always(() => {
                        M.updateTextFields()
                        M.textareaAutoResize($("#xampl_template"))
                     })
            }
         },

         getConfigData() {
            var newData = {
               kex: {
                  corpus: $("#kex_corpus").attr("corpname"),
                  concquery: $("#kex_concquery").val(),
                  concsampling:$("#kex_concsampling").val(),
                  searchElements: $("#kex_searchElements select").val()
               },
               xampl: {
                  container: $("#xampl_container select").val()
                  //template: $("#xampl_template").val(),
                  //markup: $("#xampl_markup select").val(),
               },
               collx: {
                  container: $("#collx_container select").val()/*,
                  template: $("#collx_template").val(),*/
               },
               defo: {
                  container: $("#defo_container select").val()/*,
                  template: $("#defo_template").val(),*/
               },
               thes: {
                  container: $("#thes_container select").val()/*,
                  template: $("#thes_template").val(),*/
               },
            }
            return newData
         },

         saveData() {
            this.update({isSaving: true})
            this.store.updateDictionaryConfig("ske", this.getConfigData())
                  .always(() => this.update({isSaving: false}))
         },

         refreshCorpusNote(corpus){
            if(!corpus){
               $("#corpusInfo").hide()
            } else {
               $("#corpusInfo").html(`Currently selected corpus: ${corpus.value}, show <a href="${this.dictData.siteconfig.ske_url}#dashboard?corp_info=1&corpname=${encodeURIComponent(corpus.value)}" target="ske">detailed corpus info</a>.`)
                     .show()
            }
         }
      }
   </script>

   <style>
      #kex_concsampling {
         width: 4em;
      }
      .dropdown-content {
         min-width: 250px;
      }
      .input-field{
         max-width: 700px;
      }
   </style>
</dict-config-ske>
