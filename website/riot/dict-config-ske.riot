<dict-config-ske>
   <loading-overlay if={state.isLoading || state.isSaving}/>
   <h1 class="pageTitle">Sketch Engine connection</h1>
   <dict-configuration-issues config-id="ske"/>
   <div if={state.showMissingHeadwordWarning}
         class="section">
      <div class="message messageInfo">
         please <a href="#/{dictData.dictId}/config/titling">select headword</a> in Config-Headword first
      </div>
   </div>
   <div if={ !authData.ske_username || !authData.ske_apiKey || authData.ske_apiKey == "" || authData.ske_username == "" }
         class="message messageInfo">
      Please setup your Sketch Engine account in your <a href="#/user-profile">profile</a> settings to be able to select a corpus.
   </div>
   <template if={!state.showMissingHeadwordWarning}>
      <template if={ authData.ske_username && authData.ske_apiKey && authData.ske_username != "" && authData.ske_apiKey != "" }>
         <div class="row">
            <div class="input-field positionRelative">
               <input data-selected-corpus={ state.data.corpus }
                     type="text"
                     id="corpus"
                     disabled={state.isLoadingCorpora}
                     placeholder="{state.isLoadingCorpora ? 'Loading...' : 'Type to search in the list of corpora'}"
                     class="autocomplete"
                     placeholder="Retrieving available corpora from Sketch Engine, please wait...">
               <label for="corpus">Corpus name</label>
               <span class="helper-text">Select a Sketch Engine corpus from the list of corpora available to you.</span>
               <span class="helper-text"
                     id="corpusInfo"
                     style="display: none"></span>
               <i if={state.isLoadingCorpora}
                     class="corpusListLoadingIcon material-icons spin grey-text">donut_large</i>
            </div>
         </div>
         <div class="row">
            <div class="input-field">
               <input value={ state.data.concquery}
                     id="concquery"
                     type="text" />
               <label for="concquery">Concordance query</label>
               <span class="helper-text">The CQL query that will be used to obtain concordance from Sketch Engine. You can use placeholders for elements in the form of '%(element)', e.g. '[lemma="%(headword)"]'. If left empty the 'simple' query type will be used as configured for the respective corpus. Please note that you cannot use CQL syntax with default attribute because it is not specified.</span>
            </div>
         </div>
         <div class="row">
            <div class="input-field">
               <input value={ state.data.concsampling}
                     id="concsampling"
                     type="number" />
               <label for="concsampling">Sample size</label>
               <span class="helper-text">Whether to apply automatic sampling of the concordance. Any non-zero value means to automatically create a random sample of that size.</span>
            </div>
         </div>
         <div class="row">
            <div class="input-field">
               <element-select id="searchElements"
                     riot-value={state.data.searchElements}
                     multiple={true}/>
               <label for="searchElements">Additional search elements</label>
               <span class="helper-text">You can select any textual elements here whose content you would like to search for in Sketch Engine. A menu will be displayed next to all these elements like for the root entry element.</span>
            </div>
         </div>
      </template>
      <div class="row">
         <h2>Examples</h2>
      </div>
      <div class="row">
         <div class="input-field">
            <element-select id="exampleContainer"
                  riot-value={state.data.exampleContainer}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="exampleContainer">Example container</label>
            <span class="helper-text">Select the element which should wrap each individual example. When you pull example sentences automatically from a corpus, Lexonomy will insert one of these elements for each example sentence.</span>
         </div>
      </div>
      <div class="row">
         <h2>Collocations</h2>
      </div>
      <div class="row">
         <div class="input-field">
            <element-select id="collocationContainer"
                  riot-value={state.data.collocationContainer}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="collocationContainer">Collocation container</label>
            <span class="helper-text">Select the element which should wrap each collocation (the collocate plus any other data). When you pull collocations automatically from a corpus, Lexonomy will insert one of these elements for each collocation.</span>
         </div>
      </div>
      <div class="row">
         <h2>Thesaurus items</h2>
      </div>
      <div class="row">
         <div class="input-field">
            <element-select id="thesaurusContainer"
                  riot-value={state.data.thesaurusContainer}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="thesaurusContainer">Thesaurus item container</label>
            <span class="helper-text">Select the element which should wrap each individual thesaurus item (a word). When you pull thesaurus items automatically from a corpus, Lexonomy will insert one of these elements for each thesaurus item.</span>
         </div>
      </div>
      <div class="row">
         <h2>Definitions</h2>
      </div>
      <div class="row">
         <div class="input-field">
            <element-select id="definitionContainer"
                  riot-value={state.data.definitionContainer}
                  show-empty-value={true}
                  empty-value="(not set)"/>
            <label for="definitionContainer">Definition container</label>
            <span class="helper-text">Select the element which should wrap each definition. When you pull definitions automatically from a corpus, Lexonomy will insert one of these elements for each definition.</span>
         </div>
      </div>
   </template>
   <dict-config-buttons save-data={saveData}
         show-save={!state.showMissingHeadwordWarning}></dict-config-buttons>

   <script>
      export default {
         state: {
            isLoading: true,
            isLoadingCorpora: true,
            isSaving: false,
            showMissingHeadwordWarning: false,
            data: {
               concsampling: 0,
               searchElements: [],
               exampleContainer: "",
               collocationContainer: "",
               definitionContainer: "",
               thesaurusContainer: ""
            }
         },

         onBeforeMount(){
            if(!this.dictData.config.titling.headword){
               this.state.showMissingHeadwordWarning = true
               this.state.isLoading = false
            }
         },

         onMounted(){
            if(!this.state.showMissingHeadwordWarning){
               this.store.loadDictionaryConfig("ske")
                     .done(response => {
                        this.state.data = response.content || {}
                        this.state.data.concsampling = this.state.data.concsampling || 0
                        this.state.data.searchElements = this.state.data.searchElements || []
                        this.store.skeLoadCorpora()
                              .done(response => {
                                 this.update({isLoadingCorpora: false})
                                 let corpusList = response.data.map(corpus => {
                                    let size = corpus.sizes ? `, ${window.Formatter.numWithOrder(corpus.sizes.tokencount)} tokens` : ""
                                    return {
                                       value: corpus.corpname,
                                       label: corpus.name,
                                       info: `${corpus.language_name}${size}`
                                    }
                                 })
                                 $("#corpus").autocomplete({
                                    data: corpusList,
                                    onAutocomplete: corpus => {
                                       $("#corpus").attr("corpname", corpus.value)
                                       this.refreshCorpusNote(corpus)
                                    }
                                 })
                                 let selectedCorpus = this.state.data.corpus && corpusList.find(corpus => corpus.value == this.state.data.corpus)
                                 if(selectedCorpus){
                                    $("#corpus").val(selectedCorpus.label)
                                          .attr("corpname", selectedCorpus.value)
                                    this.refreshCorpusNote(selectedCorpus)
                                 }
                              })
                     })
                     .fail(() => {
                        this.update({isLoading: false})
                     })
                     .always(() => {
                        this.update({isLoading: false})
                        M.updateTextFields()
                     })
            }
         },

         getConfigData() {
            return {
               corpus: $("#corpus").attr("corpname"),
               concquery: $("#concquery").val(),
               concsampling:$("#concsampling").val(),
               searchElements: $("#searchElements select").val(),
               exampleContainer: $("#exampleContainer select").val(),
               collocationContainer: $("#collocationContainer select").val(),
               definitionContainer: $("#definitionContainer select").val(),
               thesaurusContainer: $("#thesaurusContainer select").val()
            }
         },

         saveData() {
            this.update({isSaving: true})
            this.store.updateDictionaryConfig("ske", this.getConfigData())
                  .always(() => this.update({isSaving: false}))
         },

         refreshCorpusNote(corpus){
            if(!corpus){
               $("#corpusInfo").hide()
            } else {
               $("#corpusInfo").html(`Currently selected corpus: ${corpus.value}, show <a href="${this.dictData.siteconfig.ske_url}#dashboard?corp_info=1&corpname=${encodeURIComponent(corpus.value)}" target="ske">detailed corpus info</a>.`)
                     .show()
            }
         }
      }
   </script>

   <style>
      .corpusListLoadingIcon{
         position: absolute;
         top: 8px;
         right: 10px;
      }
      #concsampling {
         width: 4em;
      }
      .dropdown-content {
         min-width: 250px;
      }
      .input-field{
         max-width: 700px;
      }
   </style>
</dict-config-ske>
