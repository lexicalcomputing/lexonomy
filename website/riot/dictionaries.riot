<dictionaries>
   <loading-overlay if={state.isLoading}/>
   <template if={!state.isLoading}>
      <span class="buttons right">
         <a if={authData.authorized}
               href="#opendictionaries"
               class="btn">
            <i class="material-icons left">public</i>
            public dictionaries
         </a>
         <a href="#/make"
               class="btn waves-effect waves-light">
            <i class="material-icons left">add</i>
            create new dictionary
         </a>
      </span>
      <div if={dictData.dictionaryList.length}>
         <h1 class="pageTitle">Your dictionaries</h1>
         <div class="topBar">
            <span if={dictData.dictionaryList.length}
                  class="searchBox input-field inputWithRightIcon">
                  <i class="material-icons prefix grey-text">search</i>
               <input id="searchBox"
                     oninput={onSearchInput}>
               <i onclick={onClearFilterClick}
                  class="material-icons rightIcon grey-text clickable">close</i>
            </span>

            <div if={authData.authorized}
                  id="favoriteToggleWrapper"
                  class="switch onlyFavoritesChbWrapper"
                  style="display: none;">
               <label>
                  <input id="onlyFavoritesChb"
                     type="checkbox"
                     checked={state.showOnlyFavorites}
                     onchange={onOnlyFavoritesClick} >
                  <span class="lever"></span>
                  Only favorites
               </label>
            </div>
         </div>
         <table if={state.visibleDictionaries.length}
               class="highlight">
            <thead>
               <tr>
                  <th class="checkboxColumn"></th>
                  <th class="favoriteColumn"></th>
                  <th class="titleColumn">Title</th>
                  <!--th>Language</th-->
                  <th class="sizeColumn">Size</th>
                  <th if={state.hasProgressColumn}
                       class="progressColumn">Progress</th>
                  <th class="lastEditColumn">Last edit</th>
                  <th class="actionColumn"></th>
               </tr>
            </thead>
            <tbody>
               <tr each={ (dict, idx) in state.visibleDictionaries }
                     id="r_{idx}"
                     class="{dict.selected ? 'selected' : ''}"
                     key={dict.id}>
                  <td>
                     <label if={dict.currentUserCanDelete}
                           class="checkbox">
                        <input id="chb_{idx}"
                              type="checkbox"
                              idx={idx}
                              checked={dict.selected}
                              onclick={onCheckboxClick}/>
                        <span></span>
                     </label>
                  </td>
                  <td>
                     <dict-favorite-toggle dict-id={dict.id}/>
                  </td>
                  <td class="dict">
                     <a href="#/{ dict.id }"
                           id="t_{idx}">{ dict.title }</a>
                     <span if={dict.shared} class="green white-text badge">
                        shared with me
                     </span>
                  </td>
                  <!--td class="dict-lang">
                     <template if={ dict.lang }>{ dict.lang }</template>
                  </td-->
                  <td class="dict-size grey-text">
                     {window.Formatter.num(dict.size)}
                  </td>
                  <td if={state.hasProgressColumn}>
                     <dict-progress if={dict.stats}
                           dict-id={dict.id}/>
                  </td>
                  <td>
                     <dict-last-edited last-edit={dict.last_edit}/>
                  </td>
                  <td class="dict-actions">
                     <div class="buttons">
                        <a if={ !dict.currentUserCanEdit }
                              href="#{dict.id}/edit"
                              class="clickable"
                              title="view dictionary">
                           <i class="material-icons">visibility</i>
                        </a>
                        <a if={ dict.currentUserCanEdit }
                              href="#{dict.id}/edit"
                              class="clickable"
                              title="edit dictionary">
                           <i class="material-icons">edit</i>
                        </a>
                        <a if={dict.currentUserCanEdit || dict.currentUserCanConfig || dict.currentUserCanUpload || dict.currentUserCanDownload || dict.currentUserCanDelete}
                              class="clickable"
                              onclick={onOpenDictionaryMenuClick.bind(this, dict)}>
                           <i class="material-icons">more_horiz</i>
                        </a>
                     </div>
                  </td>
               </tr>
            </tbody>
         </table>
         <ul id="dictionaryMenuDropdown"
               class="dropdown-content">
         <li class="menuActionOverview">
            <a  data-href="#%DICT_ID%">
               <i class="material-icons">dashboard</i>
               Overview
            </a>
         </li>
         <li class="menuActionConfigure">
            <a  data-href="#%DICT_ID%/config">
               <i class="material-icons">settings</i>
               Configure
            </a>
         </li>
         <li class="menuActionUpload">
            <a data-href="#%DICT_ID%/upload">
               <i class="material-icons">upload</i>
               Upload
            </a>
         </li>
         <li class="menuActionDownload">
            <a data-href="#%DICT_ID%/download">
               <i class="material-icons">download</i>
               Download
            </a>
         </li>
         <li class="menuActionClone">
            <a data-action="onCloneClick">
               <i class="material-icons">content_copy</i>
               Clone
            </a>
         </li>
         <li class="menuActionDelete">
            <a data-action="onDeleteClick">
               <i class="material-icons">delete</i>
               Delete
            </a>
         </li>
      </ul>
         <div if={!state.visibleDictionaries.length}
               class="center"
               style="margin: 10vh auto;">
            <h1 class="grey-text lighten-2">Nothing found</h1>
         </div>
         <div id="deleteAllBox"
               class="deleteAllBox z-depth-5"
               if={state.selectedCount}>
               <div>
                  Delete selected dictionaries ({state.selectedCount})?
                  <button class="btn"
                        onclick={onDeleteSelectedClick}>
                     delete
                  </button>
                  <button class="btn btn-secondary"
                        onclick={onDeselectAllClick}>
                     cancel
                  </button>
               </div>

         </div>

      </div>
      <div if={!dictData.dictionaryList.length}
            class="noDictionaries grey-text center-align clearfix">
         <h1>no dictionaries</h1>
         <div>
            You have no dictionary yet. Create one using button below.
         </div>
         <br>
         <a href="#/make"
               class="btn btn-primary waves-effect waves-light">
            <i class="material-icons left">add</i>
            create new dictionary
         </a>
      </div>
   </template>

   <script>
      export default {
         bindings: [["dispatcher", "userCameBack", "reload"],
                    ["store", "dictionaryListChanged", "onDictionaryListChange"],
                    ["store", "dictionaryListLoadingChanged", "onDictionaryListLoadingChange"],
                    ["store", "favoriteChanged", "onFavoriteChanged"]],
         state: {
            isLoading: false,
            lastCheckedIdx: null,
            visibleDictionaries: [],
            selectedCount: 0,
            query: "",
            hasFavorite: false,
            showOnlyFavorites: false,
            hasProgressColumn: true
         },

         onBeforeMount() {
            this.state.showOnlyFavorites = localStorage.getItem("showOnlyFavorites_user") == 1
            this.state.isLoading = this.dictData.isDictionaryListLoading
            if(this.dictData.isDictionaryListLoaded){
               this.state.visibleDictionaries = this.dictData.dictionaryList
               this.state.hasFavorite = this.dictData.dictionaryList.findIndex(d => d.favorite) != -1
               this.state.hasProgressColumn = this.dictData.dictionaryList.find(d => !!d.stats)
            } else if(!this.state.isLoading) {
               this.state.isLoading = true
               this.reload()
            }
         },

         onMounted(){
            if(this.dictData.isDictionaryListLoaded){
               this.state.showOnlyFavorites && this.filter()
               this.refreshShowFavoriteToggle()
            }
         },

         onBeforeUpdate(){
            this.state.selectedCount = this.state.visibleDictionaries.filter(dict => dict.selected).length
            this.state.hasFavorite = this.dictData.dictionaryList.find(d => d.favorite)
            this.state.hasProgressColumn = this.dictData.dictionaryList.find(d => !!d.stats)
         },

         onUpdated(){
            this.refreshShowFavoriteToggle()
         },

         onFavoriteChanged(){
            this.dictData.isDictionaryListLoaded = false  // force to reload dictionary list
            this.refreshShowFavoriteToggle()
         },

         onDictionaryListChange(){
            this.filter()
         },

         onDictionaryListLoadingChange(){
            if(!this.dictData.isDictionaryListLoading){
               this.update({isLoading: false})
            }
         },

         onSearchInput(evt){
            this.state.query = evt.target.value
            this.filter()
         },

         onClearFilterClick(evt){
            if($('#searchBox').val()){
               $('#searchBox').val("")
               this.state.query = ""
               this.filter()
            }
         },

         onOpenDictionaryMenuClick(dict, evt){
            evt.stopPropagation()
            evt.preventDefault()
            let menuNode = $(evt.target.parentNode)
            if(!menuNode.attr("data-target")){ // menu is not created yet
               let id = "ts_" + Date.now() + Math.floor((Math.random() * 10000))
               // create copy of the list. Without copy, UL is moved as child of target node and after riot update list is destroyed
               let list = $("#dictionaryMenuDropdown").clone()
                     .attr({id: id})
                     .appendTo($("body"))
               list.find("a").each((idx, node) => {
                        let link = $(node)
                        if(link.attr("data-href")){
                           link.attr("href", link.attr("data-href").replace("%DICT_ID%", dict.id))
                        } else {
                           link.click(evt => {
                              this[evt.currentTarget.dataset.action](dict.id)
                           })
                        }
                     })
               !dict.currentUserCanDownload && list.find(".menuActionDownload").remove()
               !dict.currentUserCanDelete && list.find(".menuActionDelete").remove()
               !dict.currentUserCanConfig && list.find(".menuActionConfigure, .menuActionClone").remove()
               !dict.currentUserCanEdit && list.find(".menuActionLink").remove()

               menuNode.attr("data-target", id)
                     .dropdown({constrainWidth: false})
                     .dropdown("open")
            }
         },

         onCheckboxClick(evt){
            let idx = $(evt.currentTarget).attr("idx")
            this.toggleLineSelection(idx, evt.shiftKey)
            this.state.lastCheckedIdx = idx
         },

         onOnlyFavoritesClick(evt){
            this.state.showOnlyFavorites = $("#onlyFavoritesChb").is(":checked")
            localStorage.setItem("showOnlyFavorites_user", this.state.showOnlyFavorites ? 1 : 0)
            this.filter()
         },

         onDeleteSelectedClick(){
            window.openConfirmDialog({
               title: "Delete dictionaries?",
               content: `Are you sure you want to delete selected dictionaries? You will not be able to undo this.`,
               confirmLabel: "Delete",
               onConfirm: () => {
                  this.update({isLoading: true})
                  let toDelete = this.state.visibleDictionaries.filter(dict => dict.selected).map(dict => dict.id)
                  this.deleteNextSelected(toDelete)
               }
            })
         },

         onDeselectAllClick(){
            this.state.visibleDictionaries.forEach(dict => {dict.selected = false})
            this.update()
         },

         onCloneClick(dictId) {
            this.update({isLoading: true})
            this.store.cloneDictionary(dictId)
         },

         onDeleteClick(dictId) {
            var dictTitle = this.store.getDictionary(dictId).title
            window.openConfirmDialog({
               title: "Delete dictionary?",
               content: `Are you sure you want to delete dictionary "${dictTitle}"? You will not be able to undo this.`,
               confirmLabel: "Delete",
               onConfirm: () => {
                  this.update({isLoading: true})
                  this.store.deleteDictionary(dictId)
                        .always(() => {this.update({isLoading: false})})
               }
            })
         },

         reload(){
            !this.dictData.isDictionaryListLoading && this.store.loadDictionaryList()
                  .always(() => {
                     this.update({isLoading: false})
                  })
         },

         filter(){
            this.dictData.dictionaryList.forEach(c => {
               delete c.h_title
            })
            this.state.visibleDictionaries = this.dictData.dictionaryList
            if(this.state.showOnlyFavorites){
               this.state.visibleDictionaries = this.state.visibleDictionaries.filter(d => d.favorite)
            }
            if(this.state.query !== ""){
               let sortResult = FuzzySort.go(this.state.query, this.state.visibleDictionaries, {
                  key: "id",
                  keys: ["title"],
                  threshold: -10000
               })
               this.state.visibleDictionaries = sortResult.map(fs => {
                  fs.obj.h_title = FuzzySort.highlight(fs[0], '<b class="red-text">', "</b>")
                  fs.obj.score = fs.score
                  return fs.obj
               }).sort((a, b) => {
                  return (a.score == b.score) ? a.title.localeCompare(b.title, undefined, {numeric: true}) : Math.sign(b.score - a.score)
               })
            }
            this.update()
            this.highlightOccurrences()
         },

         toggleLineSelection(idx, shiftKey){
            let selected = $("#chb_" + idx).prop("checked")
            let fromIdx = shiftKey ? Math.min(idx, this.state.lastCheckedIdx) : idx
            let toIdx = shiftKey ? Math.max(idx, this.state.lastCheckedIdx) : idx
            for(let i = fromIdx; i <= toIdx; i++){
               this.state.visibleDictionaries[i].selected = selected
            }
            this.update()
         },

         highlightOccurrences(){
            let el, row
            this.state.visibleDictionaries.forEach((c, idx) => {
               row = this.$(`#r_${idx}`)
               if(row){
                  el = this.$(`#t_${idx}`)
                  el.innerHTML = c.h_title ? c.h_title : el.innerHTML.replace(/<b class="red-text">|<\/b>/g, '')
               }
            }, this)
         },

         refreshShowFavoriteToggle(){
            if(this.authData.authorized){
               let hasFavorite = this.dictData.dictionaryList.findIndex(d => d.favorite) != -1
               $("#favoriteToggleWrapper").toggle(hasFavorite || this.state.showOnlyFavorites)
               !hasFavorite && localStorage.setItem("showOnlyFavorites_open", 0)
            }
         },

         deleteNextSelected(toDelete){
            if(toDelete.length){
               this.store.deleteDictionary(toDelete.pop())
                     .always(this.deleteNextSelected.bind(this, toDelete))
            } else {
               this.state.visibleDictionaries = this.dictData.dictionaryList
               this.state.isLoading = false
               this.filter()
            }
         }
      }
   </script>

   <style type="scss">
      .topBar{
         display: flex;
         align-items: center;
         flex-wrap: wrap;
      }
      .searchBox{
         max-width: 200px;
         display: inline-block;
         margin: 0 15px 0 0;
      }
      .onlyFavoritesChbWrapper{
         margin-left: 2rem;
      }
      .checkboxColumn,
      .favoriteColumn,
      .sizeColumn,
      .lastEditColumn,
      .actionColumn{
         width: 1px;
      }
      .progressColumn{
         min-width: 100px;
         text-align: center;
      }
      tr .checkbox input[type="checkbox"]+span{
         padding-left: 20px;
         height: 19px;
      }
      .dict .badge{
         margin-left: 10px;
         font-size: 0.8rem;
      }
      .dict-size {
         text-align: right;
         padding-right: 15px;
         white-space: nowrap;
      }
      .dict-actions{
         .buttons{
            justify-content: flex-end;
         }
      }
      .dict-actions dict-favorite-toggle{
         vertical-align: initial;
      }
      table{
         margin-bottom: 90px;
         td{
            padding: 10px 10px;
         }
         .checkbox{
            span{
               opacity: 0.2;
            }
            &:hover{
               span{
                  opacity: 1;
               }
            }
            input:checked + span{
               opacity: 1
            }
         }
      }
      tbody tr.selected{
         background-color: #fffde7 !important;
      }
      .deleteAllBox{
         text-align: center;
         position: fixed;
         bottom: 0;
         left: 0;
         right: 0;
         padding: 20px;
         background-color: white;
         font-size: 1.2rem;
         z-index: 9990;
         button{
            margin-left: 20px;
         }
      }
      .noDictionaries{
         padding-top: 10vh;
      }
   </style>
</dictionaries>
