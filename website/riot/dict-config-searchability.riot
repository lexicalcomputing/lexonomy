<dict-config-searchability>
   <loading-overlay if={state.isLoading || state.isSaving}/>
   <template if={!state.isLoading}>
      <h1 class="pageTitle">Searching</h1>
      <dict-configuration-issues config-id="searchability"/>
      <h2>Searchable elements</h2>
      <div if={!state.hasElements}
            class="grey-text">
         <h3>No elements found</h3>
      </div>
      <div if={state.hasElements}>
         <div class="grey-text">
            The contents of elements you select here will be searchable (in addition to each entry's headword).
         </div>
         <br>
         <div each={element in state.elementList}
               class="elementWithCheckbox">
            <label style="padding-left: {element.indent * 30}px;">
               <input type="checkbox"
                     value={element.path}
                     checked={state.data.searchableElements && state.data.searchableElements.includes(element.path) || element.path == dictData.config.titling.headword}
                     disabled={element.path == dictData.config.titling.headword}/>
               <span style="color: {element.color};">{store.getElementDisplayedName(element.path)}</span>
            </label>
         </div>
      </div>
      <br><br>

      <h2>Search templates</h2>
      <div class="grey-text">
         Define your own entry search templates to make frequent searches easier. In Template field you can use %query% string which will be replaced with actual search term.
         <br>Example: Label='Adjectives', Template='entry.headword~=".*%query%.*" and entry.pos="-j"' will search for all adjectives containing search term in the headword. You can learn more about template syntax in Entry editor -> Advanced search.
      </div>
      <div if={!state.data.templates.length}
            class="grey-text">
         <h3 class="mt-4">no search templates</h3>
         <br>
         <a class="btn btn-primary waves-effect waves-light"
               onclick={onAddTemplateClick}>
            add template
            <i class="material-icons right">add</i>
         </a>
      </div>
      <template if={state.data.templates.length}>
         <table>
            <thead>
               <tr>
                  <th style="width: 250px;">Label</th>
                  <th>Template</th>
                  <th style="width: 1px;"></th>
               </tr>
            </thead>
            <tbody>
               <tr each={(template, idx) in state.data.templates}>
                  <td>
                     <input type="text"
                           name="label"
                           value={template.label}
                           oninput={onTemplateLabelInput.bind(this, idx)}>
                  </td>
                  <td class="positionRelative">
                     <input type="text"
                           name="template"
                           value={template.template}
                           oninput={onTemplateTemplateInput.bind(this, idx)}>
                     <span class="templateError red-text">
                        {template.error}
                     </span>
                  </td>
                  <td>
                     <a class="btn btn-flat"
                        onclick={onDeleteTemplateClick.bind(this, idx)}>
                     <i class="material-icons">delete</i>
                  </a>
                  </td>
               </tr>
            </tbody>
         </table>
         <div>
            <a class="btn waves-effect waves-light"
                  onclick={onAddTemplateClick}>
               add template
               <i class="material-icons right">add</i>
            </a>
      </template>
      </div>
   </template>

   <br><br>
   <dict-config-buttons save-data={saveData}
         disabled={state.isBtnSaveDisabled ? 'disabled' : ''}/>

   <script>
      export default {
         state: {
            isLoading: true,
            isSaving: false,
            hasElements: false,
            data: null
         },

         onBeforeMount() {
            this.state.elementList = window.nvhStore.getElementTreeList()
            this.state.hasElements = this.state.elementList.length
         },

         onMounted() {
            this.store.loadDictionaryConfig("searchability")
                  .done(response => {
                     this.state.data = response.content
                     this.state.data.templates = this.state.data.templates || []
                  }).always(() => {
                     this.update({isLoading: false})
                  })
         },

         onBeforeUpdate(){
            this.state.isBtnSaveDisabled = !this.state.hasElements
                  || this.state.data && Object.values(this.state.data.templates).filter(t => t.error).length > 0
         },

         onAddTemplateClick(evt) {
            this.state.data.templates.push({
               label: "",
               template: ""
            })
            this.update()
         },

         onDeleteTemplateClick(idx) {
            this.state.data.templates.splice(idx, 1)
            this.update()
         },

         onTemplateLabelInput(idx, evt){
            this.state.data.templates[idx][evt.target.name] = evt.target.value
         },

         onTemplateTemplateInput(idx, evt){
            let template = evt.target.value
            let oldError = this.state.data.templates[idx].error
            this.state.data.templates[idx].template = template
            try{
               this.store.advancedSearchParseQuery(template)
               delete this.state.data.templates[idx].error
            } catch(e){
               this.state.data.templates[idx].error = e
            }
            if(oldError != this.state.data.templates[idx].error){
               this.update()
            }
         },

         getConfigData() {
            return {
               searchableElements: $('input[type="checkbox"]:checked').toArray().map(function(elem){
                  return $(elem).attr("value")
               }),
               templates: this.state.data.templates
            }
         },

         saveData() {
            let templates = this.state.data.templates.map(template => template.label.toLowerCase())
            if(templates.length != new Array(...new Set(templates)).length){
               M.toast({html: "Each template label must be unique."})
            } else {
               this.update({isSaving: true})
               this.store.updateDictionaryConfig("searchability", this.getConfigData())
                     .always(() => this.update({isSaving: false}))
            }
         }
      }
   </script>

   <style type="scss">
      .templateError{
         position: absolute;
         bottom: 6px;
         display: block;
         font-size: 0.7rem;
      }
      .elementWithCheckbox{
         &:not(:hover){
            input[type="checkbox"]:not(:checked){
               & + span{
                  color: #bbbbbb !important
               }
            }
         }
      }
   </style>
</dict-config-searchability>
