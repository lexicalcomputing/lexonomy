<main class="main">
   <site-notification/>
   <loading-overlay if={state.isLoading} fullscreen=1/>
   <modal-dialog/>
   <app-header page={state.page}/>
   <div class="contentWrapper">
      <loading-overlay if={!state.isLoading && dictData.isDictionaryLoading}/>
      <div if={!state.isLoading }
            is={ state.page }
            class="container content {state.fullWidth ? 'fullWidthContainer' : 'wideContainer'} row"
            {...state.pageProps}
            step={state.pageProps.step}></div>
   </div>
   <app-footer/>

   <script>
      export default {
         bindings: [["auth", "authChanged", "onAuthChanged"],
                    ["auth", "checkingAuthChanged", "onCheckingAuthChange"],
                    ["store", "isDictionaryLoadingChanged", "update"],
                    ["store", "dictionaryChanged", "onDictionaryChanged"],
                    ["store", "unauthorizedDictionary", "onUnauthorizedRequest"]],

         state: {
            isLoading: true,
            page: '',
            pageProps: {},
            fullWidth: false
         },

         onBeforeMount() {
            route.parser(undefined, this.routeParser)
            let authPromise = this.auth.checkAuthCookie()
            let siteConfigPromise = this.store.loadSiteconfig()
            Promise.all([authPromise, siteConfigPromise])
                  .then(this.onSessionAndSiteconfigLoaded.bind(this))
            this.connection = window.connection
            let appUpdater = new window.AppUpdaterClass({
               url: window.window.API_URL + 'version.txt',
               windowVersionKey: 'LEXONOMY_VERSION'
            })
            this.setFontSizeFromCookies()

            route('/api', () => {
               this.goTo('api')
            })
            route('/e404', () => {
               this.goTo('e404')
            })
            route('/home', () => {
               this.goTo('login')
            })
            route('/login', () => {
               this.goTo('login')
            })
            route('unauthorized', () => {
               this.goTo('unauthorized')
            })
            route('/opendictionaries', () => {
               this.goTo('open-dictionaries')
            })
            route('/createaccount/*', (token) => {
               this.goTo('register-password', '', {token: token})
            })
            route('/recoverpwd/*', (token) => {
               this.goTo('forgot-password', '', {token: token})
            })
            route('/register', () => {
               this.goTo('register')
            })
            route('/forgot', () => {
               this.goTo('forgot')
            })
            route('/user-profile', () => {
               this.goTo('user-profile')
            })
            route('make', () => {
               this.goTo('new-dictionary', null, {step: "start"})
            })
            route('make/*', (step) => {
               this.goTo('new-dictionary', null, {step: step})
            })
            route('projects/dashboard', () => {
               this.goTo('projects-dashboard')
            })
            route('projects/new', () => {
               this.goTo('projects-new')
            })
            route('projects/view/*', (projectID) => {
               this.goTo('projects-view', null, {projectID: projectID})
            })
            route('projects/edit/*', (projectID) => {
               this.goTo('projects-edit', null, {projectID: projectID})
            })
            route('/*/edit(\?*){0,1}', (dictId) => {
               this.goTo('dict-edit', [dictId])
            })
            // just backward compatibility for old links, can be removed in future
            route('/*/edit/*(\?*){0,1}', (dictId, doctype) => {
               this.goTo('dict-edit', [dictId])
            })
            route('/*/edit/([0-9]+|new)(\?*){0,1}', (dictId, entryId) => {
               this.goTo('dict-edit', [dictId, entryId, "view"])
            })
            // just backward compatibility for old links, can be removed in future
            route('/*/edit/*/([0-9]+|new)(\?*){0,1}', (dictId, doctype, entryId) => {
               this.goTo('dict-edit', [dictId, entryId, "view"])
            })
            route('/*/edit/*/([0-9]+|new)/*(\?*){0,1}', (dictId, doctype, entryId, editorMode) => {
               this.goTo('dict-edit', [dictId, entryId, editorMode])
            })
            // just backward compatibility for old links, can be removed in future
            route('/*/edit/([0-9]+|new)/*(\?*){0,1}', (dictId, entryId, editorMode) => {
               this.goTo('dict-edit', [dictId, entryId, editorMode])
            })
            route('/*/config/*', (dictId, configId) => {
               this.goTo('dict-config-' + configId, [dictId])
            })
            route('/*/config', (dictId) => {
               this.goTo('dict-config', [dictId])
            })
            route('/*/download', (dictId) => {
               this.goTo('dict-download', [dictId])
            })
            route('/*/upload', (dictId) => {
               this.goTo('dict-upload', [dictId])
            })
            route('/admin/users/add', () => {
               this.goTo('admin-users-add')
            })
            route('/admin/users', () => {
               this.goTo('admin-users')
            })
            route('/admin/dicts', () => {
               this.goTo('admin-dicts')
            })
            route('/*', (dictId) => {
               this.goTo('dict-public', [dictId])
            })
            route('/(\?*){0,1}', () => {
               if(this.authData.authorized){
                  this.goTo('dictionaries')
               } else {
                  this.goTo('login')
               }
            })
         },

         onMounted(){
            setTimeout(() => {
               window.onfocus = () => {
                  if(((new Date().getTime() - this.state.lastBlur) / 1000) > 15){
                     // trigger "userCameBack" only if user was away more than seconds 15 seconds (prevent too many date )
                     window.dispatcher.trigger("userCameBack")
                  }
               }
            }, 1000)
            window.onblur = () => {
               this.state.lastBlur = new Date().getTime()
            }
         },

         onBeforeUpdate(){
            if(this.state.page == "unauthorized"){
               this.store.resetDictionary()
            }
            this.state.fullWidth = this.state.page == "dict-config-formatting"
            this.state.isLoading = (this.authData.isCheckingAuth && this.state.page != "login")
                  || this.dictData.isSiteconfigLoading
            this.dictData.actualPage = this.state.page
         },

         onSessionAndSiteconfigLoaded(){
            if(this.dictData.siteconfig.customStyle){
               $("head").append(`<link rel="stylesheet" type="text/css" href="${this.dictData.siteconfig.customStyle}">`)
            }
            $("#appOverlay").fadeOut().find(".appSpinner").hide()
            if(["", "/"].includes(route._.getPathFromBase()) && this.dictData.siteconfig.homepage){
               window.location.href = this.dictData.siteconfig.homepage
            }
            route.start()
            route.exec()
         },

         onAuthChanged(){
            if(this.authData.authorized){
               if(route.query().next){
                  window.location.href = decodeURIComponent(route.query().next)
               } else {
                  this.store.resetDictionary()  // dictionary cloud be loaded as unauthorized with userAccess: false
                  this.update()
               }
            } else {
               this.update({page: "unauthorized"})
            }
         },

         onCheckingAuthChange(){
            this.update()
            if(this.authData.authorized){
               this.store.loadDictionaryList()
               this.checkConsentAndShowConsentDialog()
            }
         },

         onUnauthorizedRequest(){
            this.update({page: "unauthorized"})
         },

         onDictionaryChanged(){
            if(!this.dictData.userAccess && !this.dictData.public && !this.authData.authorized){
               this.state.page = "unauthorized"
            }
            this.update()
         },

         goTo(page, storeParams, pageProps){
            if(!storeParams){
               this.checkAccessAndOpenPage(page, pageProps)
            } else {
               this.store.open(...storeParams)
               let query = route.query()
               this.store.changeSearchParams({
                  tab: query.t,
                  searchtext: decodeURIComponent(query.s || ""),
                  modifier: query.m,
                  advanced_query: decodeURIComponent(query.q || ""),
                  isCompleted: decodeURIComponent(query.c || "") || null
               })
               if(this.store.data.isDictionaryLoading){
                  this.store.one("isDictionaryLoadingChanged", this.checkAccessAndOpenPage.bind(this, page, pageProps))
               } else{
                  this.checkAccessAndOpenPage(page, pageProps)
               }
            }
         },

         checkAccessAndOpenPage(page, pageProps){
            if(this.hasUserAccessToThePage(page)){
               if(page.startsWith("dict-") && !this.dictData.config){
                  if(this.authData.authorized){
                     this.update({page: "dictionaries"})
                  } else {
                     this.update({page: "login"})
                  }
               } else {
                  this.update({
                     page: page,
                     pageProps: pageProps || {}
                  })
               }
            } else {
               this.update({page: "unauthorized"})
            }
            window.scrollTo(0, 0)
         },

         hasUserAccessToThePage(page){
            let uA = this.store.data.userAccess
            if(this.authData.isAdmin
               || !this.needAuthorization(page)
               || ['dict-public', 'dict-edit'].includes(page) && uA
               || ['dictionaries', 'user-profile', 'new-dictionary'].includes(page) && this.authData.authorized
               || (page == "dict-download" && uA.canDownload)
               || (page == "dict-upload" && uA.canUpload)
               || (page != "dict-config-limits" && page.startsWith("dict-config") && uA.canConfig)
               || (page.startsWith("dict-edit") && uA)
               || (page.startsWith("projects-") && this.authData.isProjectManager)){
               return true
            }
            return false
         },

         needAuthorization(page){
            return !['e404', 'open-dictionaries',
               'api', 'login', 'register', 'register-password', 'forgot',
               'forgot-password'].includes(page)
         },

         checkConsentAndShowConsentDialog(){
            if(this.authData.authorized
                     && this.dictData.siteconfig
                     && this.dictData.siteconfig.consent
                     && this.dictData.siteconfig.consent.terms
                     && !this.authData.consent){
               window.modal.open({
                  tag: "user-consent",
                  showCloseButton: false,
                  dismissible: false
               })
            }
         },

         routeParser(path, filter){
            // remove trailing slashes
            path = path.replace(/\/+$/, "")
            var f = filter
               .replace(/\?/g, '\\?')
               .replace(/\*/g, '([^/?#]+?)')
               .replace(/\.\./, '.*')
            var re = new RegExp(("^" + f + "$"))
            var args = path.match(re)

            if (args) {
               return args.slice(1)
            }
         },

         setFontSizeFromCookies(){
            let size = window.getCookie("fontSize")
            if(size){
               $("html").css("font-size", size + "px")
            }
         }
      }
   </script>

   <style>
      :host.main{
         min-height: 100vh;
         display:flex;
         flex-direction:column;
      }
      .contentWrapper{
         position: relative;
         min-height: 100vh;
      }
      .content{
         min-height: 50vh;
      }
      .wideContainer{
         max-width: min(1600px, 96vw);
      }
      .fullWidthContainer{
         max-width: calc(100vw - 50px);
      }
   </style>
</main>
