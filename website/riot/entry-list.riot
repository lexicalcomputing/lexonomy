<entry-list>
   <div id="entryListSidenav"
         class="entryListContainer"
         style="width: max({dictionaryHasFlags ? '25vw' : '20vw'}, 250px);">
      <dict-entry-filter search-func={onFilterChanged}
            basic-search-on-input={true}
            on-key-down={onSearchKeyDown}/>
      <div if={dictData.isEntryListLoaded}
            class="positionRelative listWrapper">
         <loading-overlay if={dictData.isEntryListLoading}/>
         <div if={dictData.entryCount > dictData.entryList.length}
               class="entriesCountInfo">
            Showing {window.Formatter.num(dictData.entryList.length)} of {window.Formatter.num(dictData.entryCount)} entries.
         </div>
         <div class="entry-list"
               onscroll={onEntryListScroll}>
            <a each={ (entry, idx) in dictData.entryList }
                  href="#/{dictData.dictId}/edit/{entry.id}/{dictData.editorMode}{store.getEntrySearchUrlQueryString()}"
                  data-idx={idx}
                  class="entry-list-item {entry.isSaving ? 'saving' : ''} {entry.id == dictData.entryId ? 'selected' : ''} {entry.is_completed ? 'isCompleted' : ''}">
               <span class="lineNum">{idx + 1}.</span>
               <span class="headword-link {entry.id == dictData.entryId ? 'red-text' : ''}">
                  <raw-html content={entry.title || "&nbsp;"}/>
               </span>
               <span if={dictionaryHasFlags}
                     class="ml-2"
                     onclick={onOpenFlagMenuClick.bind(this, entry)}>
                  <template each={flag in entry.flags}
                        if={flag}>
                     <span if={flagConfigs[flag]}
                           class="{dictData.userAccess.canEdit ? 'pointer' : ''} badge"
                           style={getFlagStyle(flag)}>
                        {store.getFlagLabel(flag)}
                     </span>
                     <span if={!flagConfigs[flag]}
                           class="unknownFlag">
                        <i class="material-icons tiny orange-text tooltipped"
                              data-tooltip="Unknown flag">warning</i>
                              {flag}
                     </span>
                  </template>
                  <span if={!entry.flags || !entry.flags.length}
                        class="noFlag">
                     no flag
                  </span>
               </span>
            </a>
            <div if={!dictData.entryList.length && !dictData.isEntryListLoading}
                  class="noEntries">
               <h2 class="grey-text center-align">No entries</h2>
            </div>
            <div if={dictData.isLoadingMoreEntries}
                  class="loadingMoreEntries positionRelative">
               <loading-overlay/>
            </div>
         </div>
         <ul if={dictionaryHasFlags}
               id="flagDropdown"
               class="dropdown-content flagDropdown">
            <li data-flag="">
               <i class="material-icons"
                     style="color: grey">label_outline</i>
               <div>no flag</div>
               <div class="right flagKey">delete</div>
            </li>
            <li if={dictData.config.flagging.all_additive_key}
                  data-additive-toggle="1">
               <div class="positionRelative">
                  <i class="material-icons"
                        style="color: grey">label</i>
                  <span class="positionAbsolute white-text"
                        style="left: 6px;">A</span>
               </div>
               <div>{dictData.config.flagging.all_additive_label || "Add all additive flags"}</div>
               <div class="right flagKey">{dictData.config.flagging.all_additive_key}</div>
            </li>
            <li each={flag in dictData.config.flagging.flags}
                  data-flag={flag.name}>
               <i class="material-icons"
                     style="color: {flag.color}">label</i>
               <div>{flag.label}</div>
               <div class="right flagKey">{flag.key}</div>
            </li>
         </ul>
      </div>
   </div>

   <script>
      export default{
         bindings: [["dispatcher", "userCameBack", "reload"],
                    ["store", "entryListChanged", "update"],
                    ["store", "isEntryListLoadingChanged", "update"],
                    ["store", "isLoadingMoreEntriesChanged", "update"],
                    ["store", "entryIdChanged", "onEntryIdChanged"],
                    ["nvhStore","editorModeChanged", "update"]],

         state: {
            focused: false,
            size: 10,
            cursorPosition: null
         },

         onBeforeMount(){
            this.nvhStore = window.nvhStore
            this.flagConfigs = {}
            this.dictionaryHasFlags = this.dictData.config.flagging.flags && this.dictData.config.flagging.flags.length
            if(this.dictionaryHasFlags){
               this.dictData.config.flagging.flags.forEach(flagConfig => {
                  this.flagConfigs[flagConfig.name] = flagConfig
               })
            }
         },

         onMounted(){
            document.addEventListener('click', this.onDocumentClick)
            document.addEventListener('keydown', this.onDocumentKeyDown)
            this.setCursorByEntryId()
         },

         onUpdated() {
            this.updateCursor()
         },

         onBeforeUnmount(){
            document.removeEventListener('click', this.onDocumentClick)
            document.removeEventListener('keydown', this.onDocumentKeyDown)
         },

         onEntryIdChanged(){
            this.update()
            this.setCursorByEntryId()
         },

         onFilterChanged(){
            this.store.one("entryListChanged", () => {
               $(".entry-list").scrollTop(0)
            })
            this.store.loadEntryList()
            this.state.cursorPosition = 1
         },

         onSearchKeyDown(evt){
            if(!evt.shiftKey && !evt.ctrlKey && !evt.metaKey && !evt.altKey){
               if(evt.keyCode == 38){
                  evt.preventDefault()
                  this.moveCursorUp(1)
               }
               if(evt.keyCode == 40){
                  evt.preventDefault()
                  this.moveCursorDown(1)
               }
               if(evt.keyCode == 13){
                  this.openEntryAtCursorPosition()
               }
            }
         },

         onEntryListScroll(evt){
            let list = $(".entry-list", this.root)[0]
            if(list.scrollHeight - list.scrollTop <= list.clientHeight + 500){
               this.store.loadMoreEntries()
            }
         },

         onOpenFlagMenuClick(entry, evt){
            if(!this.dictData.userAccess.canEdit){
               return
            }
            evt.stopPropagation()
            let id = "ts_" + Date.now() + Math.floor((Math.random() * 10000))
            // create copy of the list. Without copy, UL is moved as child of target node and after riot update is destroyed
            let menuNode = $(evt.target)//.closest(".entry-list-item")
            $("#flagDropdown").clone()
                 .attr({id: id})
                 .data("entryid", entry.id)
                 .appendTo($("body"))
                 .find("li").each(function(idx, elem){
                     $(elem).click(function(entry){
                        if($(elem).data("additiveToggle")){
                           this.toggleAllAdditiveFlags(entry)
                        } else {
                           this.toggleEntryFlag(entry, $(elem).data("flag"))
                        }
                     }.bind(this, entry))
                 }.bind(this))
             menuNode.attr("data-target", id)
                 .dropdown({
                     constrainWidth: false,
                     coverTrigger: false,
                     container: $("body"),
                     onCloseEnd: () => {
                        let listId = menuNode.attr("data-target")
                        let dropdownInstace = M.Dropdown.getInstance(menuNode)
                        dropdownInstace && dropdownInstace.destroy()
                        $(`#${listId}`).remove()

                     }
                 })
                 .dropdown("open")
         },

         onDocumentClick(evt){
            let entryList = $(".entryListContainer")[0]
            if(entryList && evt.target.parentNode){ // no parent -> probably detached element by comoponent update()
               let inComponent = entryList.contains(evt.target)
               if(inComponent || inComponent != this.state.focused){
                  this.state.focused = inComponent
                  this.state.cursorPosition = inComponent ? $(evt.target).closest(".entry-list-item").data("idx") + 1 : null
               }
            }
         },

         onDocumentKeyDown(evt){
            if(this.state.focused && ! ["TEXTAREA", "INPUT"].includes(evt.target.nodeName)){
               if(!evt.ctrlKey && !evt.altKey && !evt.metaKey){
                  if([38, 40, 33, 34, 13].includes(evt.keyCode)){
                     evt.preventDefault()
                     if(evt.keyCode == 38){
                      this.moveCursorUp(1)
                     } else if(evt.keyCode == 40){
                         this.moveCursorDown(1)
                     } else if(evt.keyCode == 33){
                         this.moveCursorUp(this.state.size) //pgUp
                     } else if(evt.keyCode == 34){
                         this.moveCursorDown(this.state.size) // pgDown
                     } else if(evt.keyCode == 13){
                        this.openEntryAtCursorPosition()
                     }
                  } else if(this.dictionaryHasFlags && this.state.cursorPosition){
                     let entry = this.dictData.entryList[this.state.cursorPosition - 1]
                     if(entry.isSaving){
                        return
                     }
                     let flaggingConfig = this.dictData.config.flagging
                     if(evt.keyCode == 46){ //delete
                        this.store.setEntryFlag(entry.id, [])
                     } else if(evt.key == flaggingConfig.all_additive_key){
                        this.toggleAllAdditiveFlags(entry)
                     } else if(flaggingConfig.flags.map(f => f.key).includes(evt.key)){
                        let flag = flaggingConfig.flags.find(f => f.key == evt.key)
                        if(flag){
                           this.toggleEntryFlag(entry, flag.name)
                        }
                     }
                  }
               }
            }

            if((evt.ctrlKey || evt.metaKey) && evt.altKey){
               if(evt.keyCode == 37){  // left
                  this.state.focused = true
               } else if(evt.keyCode == 39){  // right
                  this.state.focused = false
               }
            }
         },

         reload(){
            this.store.reloadCurrentEntries()
                  .done(response => {
                     this.update()
                  })
         },

         moveCursorDown(step){
            if(!this.state.cursorPosition){
               this.state.cursorPosition = 1
            } else{
               this.state.cursorPosition = Math.min(this.state.cursorPosition + (step || 1), this.dictData.entryList.length)
            }
            this.updateCursor()
            this.scrollSelectedIntoView()
         },

         moveCursorUp(step){
            if(!this.state.cursorPosition){
              this.state.cursorPosition = this.dictData.entryList.length - 1
            } else {
               this.state.cursorPosition = Math.max(1,  this.state.cursorPosition - (step || 1))
            }
            this.updateCursor()
            this.scrollSelectedIntoView()
         },

         updateCursor(){
            $(".entry-list-item.focused", this.root).removeClass("focused")
            if(this.state.cursorPosition){
               const node = $(".entry-list-item:nth-child(" + this.state.cursorPosition + ")")
               $(node).addClass("focused")
            }
         },

         openEntryAtCursorPosition(){
            if(this.state.cursorPosition){
               let entry = this.dictData.entryList[this.state.cursorPosition - 1]
               if(entry){
                  this.store.changeEntryId(entry.id)
                  this.updateCursor()
               }
            }
         },

         scrollSelectedIntoView(){
            let list = $(".entry-list")[0]
            if(!list){
               return
            }
            let selectedItem = $(".entry-list .focused")[0]
            if(selectedItem){
               let offsetTop = selectedItem.offsetTop
               let rowHeight = selectedItem.clientHeight
               let min = list.scrollTop + (3 * rowHeight)
               let max = list.scrollTop + list.clientHeight - (3 * rowHeight)
               if(offsetTop < min){
                  list.scrollTop = offsetTop - (2 * rowHeight)
               } else if(offsetTop > max){
                  list.scrollTop = offsetTop - list.clientHeight + (3 * rowHeight)
               }
            }
         },

         setCursorByEntryId(){
            if(this.dictData.entryId){
               if(this.dictData.isEntryListLoaded){
                  let idx = this.dictData.entryList.findIndex(e => e.id == this.dictData.entryId)
                  if(idx != -1){
                     this.state.cursorPosition = idx + 1
                     this.updateCursor()
                     this.scrollSelectedIntoView()
                  }
               } else {
                  setTimeout(() => {
                     // without timeout another callback is pushed to list of callbacks of "entryListChanged" event and this cause infinite loop of calling this function
                     this.store.one("entryListChanged", this.setCursorByEntryId.bind(this))
                  }, 1)
               }
            }
         },

         toggleEntryFlag(entry, flag){
            let flags = entry.flags
            if(!flag){
               flags = []
            } else {
               if(flags.includes(flag)){
                  // flag is already in flags array -> toggle this flag off
                  flags = flags.filter(f => f != flag)
               } else {
                  // adding a new flag
                  let flagConfig = this.flagConfigs[flag]
                  if(!flagConfig.additive){
                     // adding exclusive flag -> remove all other flags
                     flags = [flag]
                  } else {
                     // adding additive flag -> remove all exclusive flags
                     if(flags.length){
                        flags = flags.filter(f => {
                           let fConfig = this.flagConfigs[f]
                           return fConfig && fConfig.additive
                        })
                     }
                     flags.push(flag)
                  }
               }
            }
            this.store.setEntryFlag(entry.id, flags)
         },

         toggleAllAdditiveFlags(entry){
            let flags = entry.flags
            let additiveFlagList = this.dictData.config.flagging.flags.filter(flag => flag.additive)
                  .map(flag => flag.name)
            if(new Set(entry.flags).size == additiveFlagList.length){
               this.store.setEntryFlag(entry.id, []) // has all additive flags -> toggle them off
            } else{
               this.store.setEntryFlag(entry.id, additiveFlagList)
            }
         },

         getFlagStyle(flag){
            let bgColor = this.store.getFlagColor(flag) || 'initial'
            let color = this.store.getFlagTextColor(bgColor)
            return `color: ${color}; background-color: ${bgColor}`
         }
      }
   </script>


   <style type="scss">
      li > span {
         white-space: nowrap;
      }
      .listWrapper{
         min-height: 50vh;
      }
      .entry-list {
         max-height: 100vh;
         overflow-y: auto;
      }
      .entriesCountInfo{
         font-size: 0.85rem;
         color: #b8b8b8;
      }
      .entry-list-item{
         position: relative;
         display: flex;
         border-left: 5px solid white;
         text-decoration: none;
         border-bottom: 1px solid #e0e0e0;
         line-height: 1.5rem;
         padding: 0.5rem 0.5rem 0.5rem 0.2rem;
         &:hover{
            background-color: #eee;
         }
         &.isCompleted{
            background-color: #f1f8e9;
            border-left-color: #4CAF50;
            &:hover,
            &.selected{
               background-color: #dcedc8;
            }
            &.selected{
               border-left-color: #1B5E20;
            }
         }
         &.selected{
            border-left-color: #000;
         }
         &.saving{
            &::before{
               content: '';
               position: absolute;
               left: 0;
               right: 0;
               top: 0;
               bottom: 0;
               background-color: #ffffffe8;
               line-height: 100%;
               z-index: 500;
            }
            &::after{
               content: 'saving...';
               position: absolute;
               transform: translateX(-50%) translateY(-50%);
               left: 50%;
               top: 50%;
               color: #6e6e6e;
               z-index: 501;
               font-size: 1.3rem;
               text-transform: uppercase;
            }
         }
         .headword-link{
            text-decoration: none;
            font-size: 1.2rem;
            letter-spacing: 1px;
            margin-right: auto;
            &:hover{
               color: #F44336;
            }
         }
         .flagKey{
            font-family: monospace;
         }
         .badge{
            margin-top: 0;
            font-weight: bold;
            min-width: auto;
            box-shadow: 0 2px 2px 0 rgb(0 0 0 / 14%),
               0 3px 1px -2px rgb(0 0 0 / 12%),
               0 1px 5px 0 rgb(0 0 0 / 20%);
         }
         .unknownFlag{
            i{
               position: relative;
               top: 2px;
               margin-right: 3px;
            }
         }
         .noFlag{
            white-space: nowrap;
            font-size: 1rem;
            color: grey;
         }
      }
      .loadingMoreEntries{
         height: 130px;
      }
      .lineNum{
         font-size: 0.8rem;
         color: #b8b8b8;
         margin-right: 10px;
         min-width: 30px;
         text-align: right;
      }
      .entryListContainer{
         min-height: 50vh;
         transition: width 0.2s;
      }
      .noEntries{
         padding-top: 10vh;
      }
   </style>

</entry-list>
