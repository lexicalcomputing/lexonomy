<project-batches>
   <div class="batchesBar displayFlex">
      <div class="searchBox input-field">
         <input id="searchBox"
               placeholder="search"
               oninput={onBatchSearchInput}>
         <i onclick={onBatchSearchCancelClick}
               class="material-icons rightIcon grey-text clickable">close</i>
         <div class="helper-text">
            showing {state.displayedBatches.size} of {props.workflow.batches.length} batches
         </div>
      </div>
   </div>
   <div if={props.workflow.batches.length && !state.displayedBatches.size}>
      <h3 class="grey-text center-align mt-6 mb-6">
         no batches found
      </h3>
   </div>
   <div class="batchTableWrapper {state.showAllBatches ? 'showAllBatches' : ''}">
      <table if={props.workflow.batches.length && state.displayedBatches.size}
            class="batchTable">
         <thead>
            <tr>
               <th></th>
               <th class="bathcEditorColumn">
                  <a href="javascript:void(0);"
                        onclick={onBatchSortClick.bind(this, "assignee")}>
                     editor
                  </a>
               </th>
               <th>
                  <a href="javascript:void(0);"
                        onclick={onBatchSortClick.bind(this, "status")}>
                     status
                  </a>
               </th>
               <th>
                  <a href="javascript:void(0);"
                        onclick={onBatchSortClick.bind(this, "size")}>
                     size
                  </a>
               </th>
               <th>
                  <a href="javascript:void(0);"
                        onclick={onBatchSortClick.bind(this, "dictionary")}>
                     dictionary
                  </a>
               </th>
               <th class="batchActionColumn"></th>
            </tr>
         </thead>
         <tbody>
            <tr each={batch in props.workflow.batches}
                  if={state.displayedBatches.has(batch.dictID)}
                  class="batch{batch.status ? window.capitalize(batch.status) : "In progress"}
                        {state.selectedBatches.has(batch.dictID) ? 'selectedBatch' : ''}
                        {batch.isBusy || batch.satus == 'creating' ? 'pointerEventsNone' : ''} positionRelative">
               <td>
                  <div if={batch.isBusy || batch.status == 'creating'}
                        class="batchLoadingOverlay">
                     <i class="material-icons spin grey-text">donut_large</i>
                  </div>
                  <input type="checkbox"
                     checked={state.selectedBatches.has(batch.dictID)}>
                  <label class="checkbox">
                     <input type="checkbox"
                           checked={state.selectedBatches.has(batch.dictID) ? 'checked' : ''}
                           onclick={onBatchCheckboxClick.bind(this, batch)}/>
                     <span></span>
                  </label>
               </td>
               <td>
                  <span if={batch.edit}
                        class="input-field">
                     <input type="text"
                           class="assigneeAutocomplete autocomplete {!batch.assignee ? 'grey-text' : ''}"
                           onblur={onBatchAssigneeBlur.bind(this, batch)}>
                  </span>
                  <span if={!batch.edit}
                        title={batch.assignee}
                        class="assigneeReadOnly {!batch.assignee && batch.status != "rejected" ? 'grey-text' : ''}
                              {batch.status == "rejected" ? 'disabled' : ''}"
                        onclick={onBatchAssigneeClick.bind(this, batch)}>
                     {batch.assignee ? window.trim(batch.assignee, 30)/*.split("@")[0]*/ : "--unassigned--"}
                     <i if={batch.status != "rejected"}
                           class="material-icons tiny">edit</i>
                  </span>
               </td>
               <td>
                  <div if={batch.status == "creating"}
                        class="grey-text">
                     creating...
                  </div>
                  <div if={batch.status != "creating"}
                        class="batchProgress">
                     <div class="batchProgressBar progress">
                        <div class="determinate {window.getProgressColorClass(batch.completed_per)}"
                              style="width: {batch.completed_per}%"></div>
                     </div>
                     <span class="batchProgressPercentage">
                        {batch.completed_per} %
                     </span>
                     <span if={batch.status == "rejected"}
                           class="progressIcon grey tooltipped"
                           data-tooltip="Rejected batch">
                        <i class="material-icons">close</i>
                     </span>
                     <span if={batch.status == "accepted"}
                           class="progressIcon green tooltipped"
                           data-tooltip="Accepted batch">
                        <i class="material-icons">check</i>
                     </span>
                  </div>
               </td>
               <td>
                  {window.Formatter.num(batch.total)}
               </td>
               <td>
                  <a href="#/{batch.dictID}"
                        title={batch.dictID.length > 15 ? batch.dictID : null}>{window.shortenText(batch.dictID, 15)}</a>
               </td>
               <td>
                  <div class="batchActionButtons displayFlex">
                     <button if={batch.status != "rejected"}
                           class="btn btn-flat btn-floating btn-small tooltipped"
                           data-tooltip="Reject batch"
                           onclick={onBatchRejectClick.bind(this, batch)}>
                        <i class="material-icons">close</i>
                     </button>
                     <span if={batch.completed_per == 100 && batch.status != "accepted"}
                           class="tooltipped"
                           data-tooltip={batch.status == "rejected" && batch.newerBatchExists ? "If you want to accept this batch you need to delete all newer batches first" : "Accept batch"}>
                        <button class="btn btn-flat btn-floating btn-small {batch.newerBatchExists ? 'disabled' : ''}"
                              onclick={onBatchAcceptClick.bind(this, batch)}>
                           <i class="material-icons">check</i>
                        </button>
                     </span>
                     <button class="btn btn-flat btn-floating btn-small tooltipped"
                           data-tooltip="Delete batch"
                           onclick={onBatchDeleteClick.bind(this, batch)}>
                        <i class="material-icons">delete</i>
                     </button>
                  </div>
               </td>
            </tr>
         </tbody>
      </table>
   </div>
   <div class="batchBottomBar mt-2 pt-2">
      <div>
         <button class="dropdown-trigger btn {state.selectedBatches.size ? '' : 'disabled'}"
               data-target="bulkActionDropdown"
               onclick={onBulkActionDropdownButtonClick}>bulk action
            <i class="material-icons right">arrow_drop_down</i>
         </button>
         <div if={state.selectedBatches.size}>
            <small class="grey-text">selected {state.selectedBatches.size} batches</small>
         </div>
         <ul id="bulkActionDropdown"
               class="dropdown-content">
            <li class="batchBulkActionAccept">
               <a href="javascript:void(0);"
                     onclick={onBulkActionClick.bind(this, "accepted")}>
                  Accept
                  <i class="material-icons">check</i>
               </a>
            </li>
            <li class="batchBulkActionReject">
               <a href="javascript:void(0);"
                     onclick={onBulkActionClick.bind(this, "reject")}>
                  Reject
                  <i class="material-icons">close</i>
               </a>
            </li>
            <li class="batchBulkActionSetEditor">
               <a href="javascript:void(0);"
                     onclick={onBulkActionClick.bind(this, "setAssignee")}>
                  Set editor
                  <i class="material-icons">person</i>
               </a>
            </li>
            <li class="batchBulkActionClose">
               <a href="javascript:void(0);"
                     onclick={onBulkActionClick.bind(this, "delete")}>
                  Delete
                  <i class="material-icons">delete</i>
               </a>
            </li>
         </ul>
      </div>
      <div class="ml-auto">
         <a href="javascript:void(0)"
               class="displayInlineBlock"
               onclick={props.parentTag.onToggleShowBatches.bind(null, props.workflowIdx)}>
            <i class="material-icons right">keyboard_arrow_up</i>
            hide batches
         </a>
         <a if={props.workflow.batches.length >= 12}
               href="javascript:void(0)"
               class="displayInlineBlock"
               onclick={onToggleShowMoreBatches}>
            <i class="material-icons right">
               {state.showAllBatches ? "keyboard_arrow_up" : "keyboard_arrow_down"}
            </i>
            {state.showAllBatches ? "show less" : "show all"}
         </a>
      </div>
   </div>

   <script>
      export default{
         state: {
            selectedBatches: null,
            displayedBatches: null,
            lastSelectedBatch: null,
            showAllBatches: true,
            editors: []
         },

         onBeforeMount(){
            this.state.selectedBatches = new Set()
            this.refreshDisplayedBatches()
         },

         onMounted(){
            $(".dropdown-trigger", this.root).dropdown({
               coverTrigger: false,
               alignment: "top",
               constrainWidth: false
            })
         },

         onBeforeUpdate(){
            this.state.annotators = [...(this.props.project.annotators.__all__ || []), ...(this.props.project.annotators[this.props.workflow.stage] || [])]
            this.refreshDisplayedBatches()
         },

         onToggleShowMoreBatches(){
            this.update({showAllBatches: !this.state.showAllBatches})
         },

         onBatchRejectClick(batch){
            this._rejectBatches([batch])
         },

         onBatchAcceptClick(batch){
            this._acceptBatches([batch])
         },

         onBatchDeleteClick(batch){
            this._deleteBatches([batch])
         },

         onBulkActionDropdownButtonClick(){
            let showAccept = false
            let showReject = false
            this.props.workflow.batches.filter(b => this.state.selectedBatches.has(b.dictID)).forEach(batch => {
               if( batch.status != "accepted" && batch.completed_per == 100 && !batch.newerBatchExists){
                  showAccept = true
               }
               if(batch.status != "rejected"){
                  showReject = true
               }
            })
            $(".batchBulkActionAccept").toggle(showAccept)
            $(".batchBulkActionReject").toggle(showReject)
         },

         onBatchSearchInput(evt){
            this.update({searchQuery: evt.target.value})
         },

         onBatchSearchCancelClick(){
            this.state.searchQuery = ""
            this.state.displayedBatches = new Set(this.props.workflow.batches.map(batch => batch.dictID))
            $(".searchBox input", this.root).val("")
            this.update()
         },

         onBatchSortClick(orderBy){
            if(this.props.workflow.orderBy == orderBy){
               this.props.workflow.desc = !this.props.workflow.desc
            } else {
               this.props.workflow.orderBy = orderBy
               this.props.workflow.desc = false
            }
            this.store.projectSortBatches(this.props.workflow.batches, this.props.workflow.orderBy, this.props.workflow.desc)
            this.update()
         },

         onBatchCheckboxClick(batch, evt){
            this.toggleBatchSelection(batch, evt.shiftKey)
            this.state.lastSelectedBatch = batch
         },

         onBatchAssigneeClick(batch, evt){
            batch.edit = true
            let td = $(evt.target).closest("td") // find td before update. After update evt.target does no exist anymore
            this.update()
            td.find("input").focus()
            $(".assigneeAutocomplete", this.root).autocomplete({
               data: this.state.annotators.map(email => {
                     return {
                        value: email,
                        label: email
                     }
               }),
               dropdownOptions: {
                  container: this.root,
                  constrainWidth: false
               },
               onAutocomplete: function(batch, assignee){
                  this.onBatchAssigneeChange(batch, assignee.value)
               }.bind(this, batch)
            })
         },

         onBatchAssigneeBlur(batch){
            batch.edit = false
            this.update()
         },

         onBatchAssigneeChange(batch, email){
            batch.edit = false
            if(this.state.annotators.includes(email)){
               batch.assignee = email
               this._setAssignees([batch], email)
            }
         },

         onBulkActionClick( action, evt){
            let selectedBatches = this.props.workflow.batches.filter(b => this.state.selectedBatches.has(b.dictID))
            if(action == "accepted"){
               this._acceptBatches(selectedBatches)
            } else if(action == "reject"){
               this._rejectBatches(selectedBatches)
            } else if(action == "delete"){
               this._deleteBatches(selectedBatches)
            } else if(action == "setAssignee"){
               window.modal.open({
                  title: "Set editor",
                  tag: "user-dropdown",
                  small: true,
                  overflowVisible: true,
                  props: {
                     onChange: user => {
                        $("#btnBulkChangeAssignee").toggleClass("disabled", !user.email)
                     }
                  },
                  buttons: [{
                     label: "set editor",
                     id: "btnBulkChangeAssignee",
                     class: "btn-primary disabled",
                     onClick: function(selectedBatches, modal, dialog){
                        let assignee = $(".modal-content lazy-dropdown input").val()
                        selectedBatches.forEach(batch => {
                           this.state.selectedBatches.delete(batch.dictID)
                        })
                        this._setAssignees(selectedBatches, assignee)
                        dialog.close()
                     }.bind(this, selectedBatches)
                  }]
               })
               setTimeout(() => {
                  $(".modal-dialog lazy-dropdown input").focus()
               }, 400)
            }
         },

         toggleBatchSelection(batch, shiftKey){
            let idx = this.props.workflow.batches.indexOf(batch)
            let lastSelectedBatchIdx = this.props.workflow.batches.indexOf(this.state.lastSelectedBatch)
            let selected = !this.state.selectedBatches.has(batch.dictID)
            let fromIdx = shiftKey ? Math.min(idx, lastSelectedBatchIdx) : idx
            let toIdx = shiftKey ? Math.max(idx, lastSelectedBatchIdx) : idx
            for(let i = fromIdx; i <= toIdx; i++){
               if(selected){
                  this.state.selectedBatches.add(batch.dictID)
               } else {
                  this.state.selectedBatches.delete(batch.dictID)
               }
            }
            this.update()
            window.initFormSelects(this.root)
         },

         refreshDisplayedBatches(){
            if(this.state.searchQuery){
               this.state.displayedBatches = new Set(this.props.workflow.batches.filter(batch => {
                     return batch.assignee.indexOf(this.state.searchQuery) != -1
                        || batch.dictID.indexOf(this.state.searchQuery) != -1
                        || batch.status.indexOf(this.state.searchQuery) != -1
                  }).map(batch => batch.dictID))
               this.state.selectedBatches = this.state.selectedBatches.intersection(this.state.displayedBatches)
            } else {
               this.state.displayedBatches = new Set(this.props.workflow.batches.map(batch => batch.dictID))
            }
         },

         _acceptBatches(batches){
            let completedBatches = batches.filter(batch => batch.completed_per == 100)
            if(completedBatches.length){
               this.store.projectAcceptBatches(this.props.project.projectID, completedBatches.map(batch => batch.dictID))
                     .always(response => {
                        this._processBatchRequestResponse(response)
                     })
               completedBatches.forEach(batch => batch.isBusy = true)
               this.update()
            }
         },

         _rejectBatches(batches){
            this.store.projectRejectBatches(this.props.project.projectID, batches.map(batch => batch.dictID))
                  .always(response => {
                     this._processBatchRequestResponse(response)
                  })
            batches.forEach(batch => batch.isBusy = true)
            this.update()
         },

         _deleteBatches(batches){
             window.modal.open({
                  title: `Delete selected ${batches.length > 1 ? 'batches' : 'batch'}`,
                  small: true,
                  content: `Are you sure you want to delete selected ${batches.length > 1 ? 'batches' : 'batch'}? This action cannot be undone.`,
                  buttons: [{
                     label: `Delete ${batches.length > 1 ? 'batches' : 'batch'}`,
                     id: "btnBulkChangeAssignee",
                     class: "btn-primary",
                     onClick: function(batches, modal, dialog){
                        this.store.projectDeleteBatches(this.props.project.projectID, batches.map(batch => batch.dictID))
                              .always(response => {
                                 this._processBatchRequestResponse(response)
                              })
                        dialog.close()
                     }.bind(this, batches)
                  }]
               })
         },

         _setAssignees(batches, email){
            let assignees = batches.map(batch => [batch.dictID, email])
            this.store.projectAssignBatch(this.props.project.projectID, assignees)
                  .always(response => {
                     this._processBatchRequestResponse(response)
                  })
            batches.forEach(batch => batch.isBusy = true)
            this.update()
         },

         _processBatchRequestResponse(response){
            if(!response.error){
               this.props.parentTag.loadProject()
            } else {
               completedBatches.forEach(batch => {
                  batch.isBusy = false
                  this.state.selectedBatches.delete(batch.dictID)
               })
               this.update()
            }
         }
      }
   </script>

   <style type="scss">
      .batchesBar{
         .searchBox{
            margin: 0;
            input{
               height: 30px;
               line-height: 30px;
               padding-right: 30px;
               width: 150px;
            }
            i{
               position: relative;
               right: 24px;
               top: 6px;
            }
         }
      }
      .batchTableWrapper{
         max-height: max(50vh, 300px);
         overflow: auto;
         &.showAllBatches{
            max-height: 100%;
         }
         tr:hover{
            .batchActionButtons{
               opacity: 1
            }
         }
      }
      .batchTable{
         th,
         td{
            padding: 2px 8px;
         }
         thead{
            tr{
               background-color: whitesmoke;
               border-bottom: 0;
               outline: 1px solid #dfdfdf;
               th:first-child{
                  width: 1px
               }
            }
            .bathcEditorColumn{
               width: 100%
            }
            .batchActionColumn{
               width: 80px;
            }
         }
         tbody{
            tr{
               .checkbox{
                  opacity: 0.3;
                  span{
                     height: 20px;
                     padding-left: 20px;
                  }
               }
               &.selectedBatch,
               &:hover{
                  .checkbox{
                     opacity: 1
                  }
               }
               .progressIcon{
                  border-radius: 50%;
                  display: inline-block;
                  width: 20px;
                  height: 20px;
                  line-height: 20px;
                  text-align: center;
                  i{
                     color: #fff;
                     font-size: 15px;
                     line-height: 20px;
                  }
               }
            }
            td{
               height: 39px;
            }
         }
         .batchLoadingOverlay{
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            background-color: rgb(250 250 250 / 85%);
            z-index: 100;
            text-align: center;
            i{
               position: absolute;
               top: calc(50% - 16px);
               left: calc(50% - 16px);
            }
         }
         .assigneeReadOnly{
            margin-right: 3px;
            &.disabled{
               pointer-events: none;
            }
            &:not(.disabled){
               cursor: pointer;
            }
            i{
               opacity: 0.3;
               margin-left: 3px;
            }
            &:hover{
               i{
                  opacity: 1
               }
            }
         }
         .assigneeAutocomplete{
            cursor: pointer;
            padding: 2px 5px;
            height: 25px;
            line-height: 25px;
         }
         .batchRejected{
            opacity: 0.5;
            background-color: #dcdcdc;
         }
         .batchAccepted{
            background-color: #C8E6C9;
         }
         .batchProgress{
            display: inline-flex;
            align-items: center;
            gap: 10px;
            position: relative;
            min-height: 34px;
            .batchProgressBar{
               width: 40px;
               top: 5px;
               margin: 0;
            }
            .batchProgressPercentage{
               position: absolute;
               display: block;
               top: 3px;
               left: 0;
               width: 40px;
               text-align: center;
               font-size: 0.8rem;
               color: grey;
            }
         }
         .batchActionButtons{
            opacity: 0.6;
         }
         .selectedBatch{
            background-color: #E3F2FD;
         }
      }
      .batchBottomBar{
         position: sticky;
         display: flex;
         height: 70px;
         bottom: 0;
         background-color: whitesmoke;
         border-bottom: 0;
         border-top: 1px solid #dfdfdf;
         z-index: 100;
         margin-left: -24px;
         margin-right: -24px;
         padding-left: 24px;
         padding-right: 24px;
      }
   </style>
</project-batches>
