<projects-view>
   <div if={!props.projectID}
         class="message error">
      <h2>Bad request</h2>
      Missing project ID. <a href="#projects/dashboard">Go to projects dashboard</a>.
   </div>

   <div if={state.error}
         class="message error">
      <h2 class="mt-8">Could not load the project</h2>
      {state.error}
      <div class="mt-4">
         <a href="#projects/dashboard">Go to projects dashboard</a>
      </div>
   </div>

   <loading-overlay if={state.isBusy}
         fullscreen={true}
         message={state.busyMessage}/>
   <template if={!state.error && state.project}>
      <div class="titleBar displayFlex alignCenter">
         <a href="#projects/dashboard"
               class="clickable mr-2 tooltipped"
               data-tooltip="Back to the projects">
            <i class="material-icons grey-text">arrow_back</i>
         </a>
         <h1 class="pageTitle">
            {state.project.project_name}
         </h1>
         <a href="#projects/edit/{state.project.projectID}"
               class="grey-text ml-2 tooltipped"
               data-tooltip="Edit project">
            <i class="material-icons">edit</i>
         </a>
         <a if={!state.isReloadingProject}
               href="javascript:void(0);"
               class="grey-text ml-2 tooltipped"
               onclick={onReloadProjectClick}
               data-tooltip="Reload project">
            <i class="material-icons">refresh</i>
         </a>
         <span>
            <i if={state.isReloadingProject}
                  class="spin grey-text text-lighten-1 ml-2 material-icons">
               donut_large
            </i>
         </span>
         <span if={!state.isReloadingProject && state.checkProjectTimeoutHandle}
               class="ml-4 grey-text">
            project is being updated...
         </span>
      </div>
      <div class="mb-4">
         <div if={state.showDetails}
               class="projectDetails grey lighten-4 mb-2 p-4">
            <label>Language</label>
            {store.getLanguageName(state.project.language)}
            <label>Description</label>
            {state.project.description}
            <label>Source dictionary:</label>
            <a href="#/{state.project.source_dict}">Open dictionary</a>
            <label>Managers:</label>
            {state.project.managers.join(", ")}
            <label>Project ID</label>
            {state.project.projectID}
         </div>
         <a href="javascript:void(0)"
               class="displayInlineBlock mr-4"
               onclick={onToggleShowDetailsClick}>
            <i class="material-icons right">
               {state.showDetails ? 'keyboard_arrow_up' : 'keyboard_arrow_down'}
            </i>
            {state.showDetails ? 'hide project details' : 'show project details'}
         </a>
      </div>

      <table class="workflowTable">
         <tbody each={(workflow, workflowIdx) in state.project.workflow}>
            <tr if={workflow.type != "merge"}>
               <td>
                  <div class="card-panel grey lighten-4 positionRelative">
                     <loading-overlay if={state.isReloadingCentralDictionary}
                           message="Reloading..."/>
                     <span if={workflow.inputDicts[0].dictID == state.project.source_dict}
                           class="sourceDictMenuDropdownBtn">
                        <button class="dropdown-trigger btn btn-floating btn-flat"
                              data-target="sourceDictMenuDropdown">
                           <i class="material-icons black-text">more_horiz</i>
                        </button>
                        <ul id="sourceDictMenuDropdown"
                              class="dropdown-content">
                           <li>
                              <a href="javascript:void(0);"
                                    onclick={onReloadSourceDictClick}>
                                 <i class="material-icons">refresh</i>
                                 Reload dictionary data
                              </a>
                           </li>
                           <li>
                              <a href="javascript:void(0);"
                                    onclick={onChangeCentralDictionaryClick}>
                                 <i class="material-icons">swap_horiz</i>
                                 Change central dictionary
                              </a>
                           </li>
                        </ul>
                     </span>
                     <project-dict-name dict={workflow.inputDicts[0]}/>
                     <div class={!workflow.inputDicts[0].total ? 'tooltipped' : ''}
                           data-tooltip={!workflow.inputDicts[0].total ? 'No entries to export, dictionary is empty.' :''}>
                        <project-export-to-batches-form class={getDictionaryStatus(workflow.inputDicts[0]).isBusy ? 'hide' : ''}
                              workflow={workflow}
                              export-to-batches={exportToBatches}/>
                        <project-dictionary-status {...getDictionaryStatus(workflow.inputDicts[0])}/>
                     </div>
                  </div>
               </td>
               <td>
                  <div class="taskIcon alignCenter">
                     <i class="material-icons rotate90CW">file_upload</i>
                  </div>
               </td>
               <td>
                  <div class="workflowWithBatchPanel positionRelative card-panel grey lighten-4">
                     <loading-overlay if={workflow.is_locked}/>
                     <div class="workflowBar borderBottom mb-2 displayFlex">
                        <h3 class="workflowName mt-0">
                           {workflow.stage}
                        </h3>
                        <div class="workflowStatus displayFlex alignCenter grey-text ml-auto">
                           <div class="workflowProgress progress">
                              <div class="determinate {window.getProgressColorClass(workflow.completed_per)}"
                                    style="width: {workflow.completed_per}%;"></div>
                           </div>
                           <span>
                              {workflow.completed_per}%
                           </span>
                        </div>
                     </div>
                     <div if={workflow.batches.length && !state.showBatches[workflowIdx]}
                           class="center-align pt-2 pb-2">
                        <a href="javascript:void(0)"
                              class="displayInlineBlock"
                              onclick={onToggleShowBatches.bind(this, workflowIdx)}>
                           <i class="material-icons right">keyboard_arrow_down</i>
                           show batches
                        </a>
                     </div>
                     <h4 if={!workflow.batches.length}
                           class="grey-text mt-12 center-align">
                        no batches have been generated
                     </h4>
                     <loading-overlay if={workflow.isExportingBatches}
                           message="Exporting batches..."/>
                     <project-batches if={workflow.batches.length && state.showBatches[workflowIdx]}
                           parent-tag={this}
                           project={state.project}
                           workflow={workflow}
                           workflow-idx={workflowIdx}/>
                  </div>
               </td>
               <td>
                  <div class="taskIcon">
                     <i class="material-icons rotate90CCW">file_download</i>
                  </div>
               </td>
               <td>
                  <div class="card-panel importPanel grey lighten-4">
                     <project-dict-name dict={workflow.outputDict}
                           hide-assigned={true}/>
                     <span if={!getDictionaryStatus(workflow.outputDict).isBusy}
                           class={!workflow.isImportAvailable ? "tooltipped" : ""}
                           data-tooltip={!workflow.isImportAvailable ? "At least one batch must be accepted to allow import." : ""}>
                        <button class="btn {!workflow.isImportAvailable ? 'disabled' : ''}"
                              onclick={onImportAcceptedBatchesClick.bind(this, workflow)}>
                           Import accepted batches
                        </button>
                     </span>
                     <project-dictionary-status {...getDictionaryStatus(workflow.outputDict)}/>
                  </div>
               </td>
            </tr>


            <tr if={workflow.type == "merge"}>
               <td>
                  <div class="card-panel grey lighten-4">
                     <template each={dict in workflow.inputDicts}>
                        <project-dict-name dict={dict}
                              hide-assigned={true}/>
                        <project-dictionary-status {...getDictionaryStatus(dict)}/>
                     </template>
                  </div>
               </td>
               <td>
                   <div class="taskIcon">
                     <i class="material-icons rotate90CW">merge_type</i>
                  </div>
               </td>
               <td>
                  <div class="card-panel grey lighten-4 positionRelative">
                     <h3 class="workflowName borderBottom mt-0">Merge dictionaries</h3>
                     <span class="alignCenter {!workflow.isMergeAvailable ? 'tooltipped' :''}"
                           data-tooltip={!workflow.isMergeAvailable ? 'Dictionaries to merge must not be empty.' : ''}>
                        <button class="btn mt-4 {!workflow.isMergeAvailable || workflow.isMerging ? 'disabled' : ''}"
                              onclick={onMergeDictionariesClick.bind(this, workflow)}>
                           Merge
                        </button>
                     </span>
                     <loading-overlay if={workflow.isMerging}
                           message="Merging..."/>
                     <h4 if={!workflow.isMergeAvailable}
                           class="grey-text pt-4 center-align">
                        Dictionaries to merge must not be empty
                     </h4>
                  </div>
               </td>
               <td>
                  <div class="taskIcon">
                     <i class="material-icons rotate90CW">merge_type</i>
                  </div>
               </td>
               <td>
                  <div class="card-panel grey lighten-4">
                     <project-dict-name dict={workflow.outputDict}
                           hide-assigned={true}/>
                     <project-dictionary-status {...getDictionaryStatus(workflow.outputDict)}/>
                  </div>
               </td>
            </tr>
         </tbody>
      </table>
   </template>


   <script>
      export default{
         bindings: [["dispatcher", "userCameBack", "onUserCameBack"]],

         state: {
            isBusy: false,
            isReloadingProject: false,
            isReloadingCentralDictionary: false,
            project: null,
            error: null,
            lastLoadedProjectID: null,
            checkProjectTimeoutHandle: null,
            showBatches: {}
         },

         onBeforeMount(){
            this.reset()
            this.loadProject()
            this.store.loadWorkflowList()
         },

         onBeforeUpdate(){
            if(!this.state.isBusy && this.state.lastLoadedProjectID != this.props.projectID){
               // user navigated to another project -> reload
               this.reset()
               this.loadProject()
            } else if(this.state.project){
               this.state.project.workflow.forEach(workflow => {
                  if(workflow.batches){
                     this.store.projectSortBatches(workflow.batches, "status")
                     workflow.completed_per = 0
                     workflow.isImportAvailable = workflow.batches.some(batch => batch.status == "accepted")
                     if(workflow.batches.length){
                        let tmp = workflow.batches.filter(batch => batch.status != "rejected")
                              .reduce((arr, batch) => {
                                 arr[0] += batch.completed || 0
                                 arr[1] += batch.total || 0
                                 return arr
                              }, [0, 0])
                        if(tmp[0] && tmp[1]){
                           workflow.completed_per = Math.floor(tmp[0] / tmp[1] * 100)
                        }
                     }
                  }
                  if(workflow.type == "merge"){
                     workflow.isMerging = this.state.runningImports.has(workflow.outputDict.title)
                     workflow.isMergeAvailable = workflow.inputDicts.every(dict => dict.total != 0 && !this.state.runningExports.has(dict.title))
                  }
               })
            }
         },

         onUpdated(){
            $(".sourceDictMenuDropdownBtn .dropdown-trigger").dropdown({
               coverTrigger: false,
               constrainWidth: false,
               container: $("#body")
            })
         },

         onBeforeUnmount(){
            this.stopProjectChecking()
         },

         onUserCameBack(){
            this.loadProject()
            this.update()
         },

         onReloadProjectClick(){
            this.loadProject()
            this.update()
         },

         onReloadSourceDictClick(){
            this.store.projectUpdateSourceDict(this.state.project.projectID, this.state.project.source_dict)
                  .done(() => {
                     this.state.isReloadingCentralDictionary = false
                     this.loadProject()
                  })
            this.update({isReloadingCentralDictionary: true})
         },

         onChangeCentralDictionaryClick(){
            let dictSelect = `<select id="centralDictionarySelect">`
                  + `<option value="" selected>-select-</option>`
                  + this.dictData.dictionaryList.map(dict => `<option value="${dict.id}">${dict.title}</option>`)
                  + "</select>"
            window.modal.open({
               title: "Change central dictionary",
               small: true,
               tag: "raw-html",
               props: {
                  content: `<div></div>${dictSelect}`
               },
               buttons: [{
                  id: "changeCentralDictionaryBtn",
                  label: "Change dictionary",
                  class: "disabled btn-primary",
                  onClick: (dialog, modal) => {
                     let source_dict = $("#centralDictionarySelect").val()
                     this.store.projectUpdateSourceDict(this.state.project.projectID, source_dict)
                           .done(response => {
                              this.state.isReloadingCentralDictionary = false
                              if(response.success){
                                 this.loadProject(this)
                                 modal.close()
                              } else {
                                 this.update()
                              }
                           })
                     this.update({isReloadingCentralDictionary: true})
                  }
               }],
               onOpen: () => {
                  $("#centralDictionarySelect").formSelect({
                     dropdownOptions: {
                        coverTrigger: false,
                        constrainWidth: false,
                        container: $("body")
                     }
                  })
                     .change(evt => {
                        document.getElementById("changeCentralDictionaryBtn").classList.toggle("disabled", !evt.target.value)
                     })
                     .focus()
               }
            })
         },

         onToggleShowDetailsClick(){
            this.update({showDetails: !this.state.showDetails})
         },

         onToggleShowBatches(workflowIdx){
            this.state.showBatches[workflowIdx] = !this.state.showBatches[workflowIdx]
            this.update()
         },

         exportToBatches(workflow, batch_size, batch_count){
            this.state.runningExports.add(workflow.inputDicts[0].title)
            this.update()
            this.store.projectExportBatches(this.props.projectID, workflow.stage, batch_size, batch_count)
                  .always(response => {
                     this.state.runningExports.delete(workflow.inputDicts[0].title)
                     workflow.is_locked = true  // make sure user does not trigger another action until project status is checked
                     this.loadProject()
                     this.update()
                  })
         },

         onImportAcceptedBatchesClick(workflow){
            this.state.runningImports.add(workflow.outputDict.title)
            this.update()
            this.store.projectImportAcceptedBatches(this.props.projectID, workflow.stage)
                  .always(response => {
                     this.state.runningImports.delete(workflow.outputDict.title)
                     this.loadProject()
                     this.update()
                  })
         },

         onMergeDictionariesClick(workflow){
            this.onImportAcceptedBatchesClick(workflow)
         },

         reset(){
            this.state.project = null
            this.state.runningExports = new Set()
            this.state.runningImports = new Set()
         },

         loadProject(){
            if(!this.props.projectID){
               return
            }
            if(this.state.lastLoadedProjectID == this.props.projectID){
               this.state.isReloadingProject = true
            } else {
               this.state.isBusy = true
               this.state.lastLoadedProjectID = this.props.projectID
            }
            this.stopProjectChecking()
            this.store.loadProject(this.props.projectID)
               .fail(response => {
                  this.state.error = response.error
                  this.state.project = null
               })
               .always(response => {
                  if(response.workflow){
                     this.state.project = response
                     this.state.project.workflow.forEach(workflow => {
                        //workflow.batch_size = 100
                        //workflow.batch_count = 1
                        if(workflow.batches){
                           workflow.displayedBatchCount = workflow.batches.length
                           workflow.batches.forEach(batch => {
                              batch.assignee = batch.assignee || ""
                              batch.status = batch.status || "inProgress"
                              batch.newerBatchExists = false
                              if(batch.created){
                                 let created = new Date(batch.created)
                                 batch.newerBatchExists = !!workflow.batches.find(b => {
                                    return b != batch && (b.status == "creating"
                                                            || (b.created && new Date(b.created) > created)
                                                         )
                                 })
                              }
                           })
                        }
                        workflow.inputDicts.forEach(dict => {
                           dict.remaining = typeof dict.remaining == "undefined" ? dict.total : dict.remaining
                        })

                        workflow.outputDict.remaining = typeof workflow.outputDict.remaining == "undefined" ? workflow.outputDict.total : workflow.outputDict.remaining
                     })
                  } else {
                     this.state.error = response.error || "unknown error"
                     this.state.project = null
                  }
                  if(this.shouldCheckProject()){
                     this.state.checkProjectTimeoutHandle = setTimeout(this.loadProject.bind(this), 5000)
                  } else {
                     this.stopProjectChecking()
                  }
                  if(!Object.keys(this.state.showBatches).length && this.state.project.workflow){
                     // after the first load initialize showBatches
                     this.state.project.workflow.forEach((workflow, workflowIdx) => {
                        this.state.showBatches[workflowIdx] = true
                        /*if(workflow.batches){
                           this.state.showBatches[workflowIdx] = workflow.batches.reduce((hasActiveBatch, batch) => {
                              return hasActiveBatch || batch.status == "inProgress"
                           }, false)
                        }*/
                     })
                  }
                  this.update({
                     isBusy: false,
                     isReloadingProject: false
                  })
               })
         },

         stopProjectChecking(){
            if(this.state.checkProjectTimeoutHandle){
               clearTimeout(this.state.checkProjectTimeoutHandle)
               this.state.checkProjectTimeoutHandle = null
            }
         },

         shouldCheckProject(){
            return this.state.project
                  && (this.state.project.workflow.some(workflow => workflow.is_locked)
                     || this.state.project.workflow.some(workflow => {
                        return workflow.batches.some(batch => batch.status == "creating")
                     }))
         },

         getDictionaryStatus(dictionary){
            let isImporting = this.state.runningImports.has(dictionary.title)
            let isExporting = this.state.runningExports.has(dictionary.title)
            return {
               isBusy: isImporting || isExporting,
               isImporting: isImporting,
               isExporting: isExporting
            }
         }/*,

         refreshExportBatchesBtnDisabled(workflow, input){
            let disabled = isNaN(workflow.batch_size)
                  || workflow.batch_size <= 0
                  || isNaN(workflow.batch_count)
                  || workflow.batch_count <= 0
            $(input).closest(".exportBatchesForm")
                  .find(".exportBtn")
                  .toggleClass("disabled", disabled)
         }*/
      }
   </script>


   <style type="scss">
      .sourceDictMenuDropdownBtn{
         float: right;
         position: relative;
         top: -8px;
         right: -8px;
      }
      .projectDetails{
         display: grid;
         grid-template-columns: 180px auto;
      }
      .workflowTable{
         width: auto!important;
         &>tbody>tr{
            border: none;
            &>td{
               padding: 0 0 30px 0;
               vertical-align: top;
            }
         }
         .card-panel{
            min-width: 270px;
            min-height: 221px;
            &.workflowWithBatchPanel{
               min-width: 600px;
               padding-bottom: 10px;
               .batchTableWrapper{
                  margin: 0 -24px;
               }
            }
            &.importPanel{
               display: flex;
               flex-direction: column;
               & > project-dict-name{
                  margin-bottom: auto;
               }
            }
         }
         .taskIcon{
            margin: 19px 15px 15px 15px;
            display: flex;
            i{
               font-size: 3rem;
               opacity: 0.2
            }
         }
      }
      .workflowName{
         padding-bottom: 0.5rem;
         margin-bottom: 0;
      }
      .workflowBar{
         gap: 5px;
         .workflowStatus{
            justify-content: end;
            .workflowProgress{
               width: 50px;
               margin: 5px;
            }
         }
      }
      .highlightDictPanel{
         background-color: #fff9c4 !important;
      }
      .highlightDictName{
         color: #ff9100 !important;
      }
      i.right{
         margin-left: 5px;
      }
   </style>
</projects-view>
