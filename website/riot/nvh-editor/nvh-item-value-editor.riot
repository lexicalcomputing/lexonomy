<nvh-item-value-editor class="nvh-item-value-editor {state.style.layout == 'block' ? 'nvh-full-width' : ''}">
   <div if={state.showEditor}
         class="nvh-text-value">
      <div class="nvh-toolbar">
         <i class="material-icons tooltipped"
               onclick={onUndoClick}
               data-tooltip="Undo (Ctrl + Z)">undo</i>
         <i class="material-icons tooltipped"
               onclick={onRedoClick}
               data-tooltip="Redo (Ctrl + Y)">redo</i>
         <button each={elementName in state.markupChildrenNames}
               class="btn markupBtn white-text tooltipped"
               name="btn_{elementName}"
               data-tooltip="Mark selected text as '{store.getElementDisplayedName(elementName)}'"
               onclick={onMarkupButtonClick.bind(this, elementName)}
               style="--background-color: {nvhStore.getElementColor(elementName)}">
            {getMarkupNumber(elementName)}: {store.getElementDisplayedName(elementName)}
         </button>

         <span class="ml-auto"></span>
         <i class="material-icons icon-close tooltipped"
               onclick={onCloseClick}
               data-tooltip="Close without saving (ESC)">close</i>
      </div>
      <div class="nvh-editable-div"
            contenteditable=true
            onkeydown={onEditableDivKeyDown}
            onkeyup={onEditableDivKeyUp}
            oninput={onEditableDivInput}
            onclick={onEditableDivClick}
            onfocus={onEditableDivFocus}
            onblur={onEditableDivBlur}>
      </div>
      <small class="nvh-save-note grey-text">
         Shift + Enter to add a new line
      </small>
   </div>
   <input if={state.config.type == "int"}
         class="nvh-input"
         type="number"
         value={props.element.value}
         onkeyup={onKeyUp}/>
   <span if={state.config.type == "bool"}>
      <label>
         <input name="bool"
               type="radio"
               value=1
               checked={props.element.value == 1}
               onchange={onBoolChange}/>
         <span>Yes</span>
      </label>
      <label>
         <input name="bool"
               type="radio"
               value=0
               checked={props.element.value != 1}
               onchange={onBoolChange}/>
         <span>No</span>
      </label>
   </span>
   <select if={state.config.type == "list"}
         class="nvh-select"
         onchange={onSelectChange}>
      <option each={value in state.config.values}
            selected={value == props.element.value}
            value={value}>{value}</option>
   </select>

   <script>
      export default{
         onBeforeMount(){
            this.nvhStore = window.nvhStore
            this.nvhData = this.nvhStore.data
            this.state.config = this.nvhStore.getElementConfig(this.props.element.name) || {}
            this.state.style = this.nvhStore.getElementStyle(this.props.element.name) || {}
            this.state.showEditor = ["string", "markup", "image", "audio", "url"].includes(this.state.config.type)
            this.state.markupChildrenNames = this.state.config.children
                  .filter(childName => this.nvhStore.getElementConfig(childName).type == "markup")
         },

         onMounted(){
            if(this.state.showEditor){
               $(".nvh-editable-div", this.root).html(this.getValueForEditor())
            } else {
               this.initFormSelect()
            }
            this.focusInput()
            if(this.state.showEditor){
               setTimeout(() => {
                  // timeout, so that clicking to open this editor does not cause it to close
                  document.addEventListener("mousedown", this.handleMouseDownOutside)
                  document.addEventListener("selectionchange", this.onSelectionChange)
                  document.addEventListener("selectstart", this.onSelectionStart)
               }, 0)
            }
         },

         onBeforeUnmount(){
            if(this.state.showEditor){
               document.removeEventListener("mousedown", this.handleMouseDownOutside)
               document.removeEventListener("selectionchange", this.onSelectionChange)
               document.removeEventListener("selectstart", this.onSelectionStart)
            }
         },

         onUndoClick(){
            document.execCommand("undo")
         },

         onRedoClick(){
            document.execCommand("redo")
         },

         onCloseClick(){
            this.nvhStore.stopElementEditing()
         },

         onMarkupButtonClick(elementName){
            let element = this.getElementUnderCaret()
            //TODO return caret to the same position after marking a word
            if(element && element.classList.contains("markupNode")){
               let sel = document.getSelection()
               let saved = [ sel.focusNode, sel.focusOffset ]
               element.outerHTML = element.innerHTML // remove markup tag
               sel.collapse(saved[0], saved[1]);
               this.state.elementUnderCaret = null
            } else if(element.classList.contains("nvh-editable-div")) {
               var sel = window.getSelection()
               if (sel) {
                 if(sel.rangeCount){
                     if(!document.getSelection().toString().length){
                        this.selectWordUnderCaret()
                     }
                     if(sel.toString().trim()){
                        const span = window.stringToElement(this.getElementMarkupHTML(elementName))
                        var range = sel.getRangeAt(0).cloneRange()
                        range.surroundContents(span)
                        sel.removeAllRanges()
                        range.collapse()
                        sel.addRange(range)
                        this.state.elementUnderCaret = elementName
                     }
                  }
               }
            }
            this.updateMarkupButtons()
         },

         onSelectionChange(evt){
            if(this.state.selectionInComponent){
               this.state.hasSelection = false
               this.state.markupElementInSelection = false
               if(document.getSelection().toString().length){
                  this.state.hasSelection = true
                  let range = document.getSelection().getRangeAt(0)
                  this.state.markupElementInSelection = this.state.markupChildrenNames.some(elementName => {
                     return $(".nvh-editable-div").find(`span[name="${elementName}"]`)
                           .toArray()
                           .some(node => range.intersectsNode(node))
                     })
                  this.onCaretPositionChange()
               }
               this.updateMarkupButtons()
            }
         },

         onCaretPositionChange(){
            let element = this.getElementUnderCaret()
            this.state.elementUnderCaret = null
            if(element && element.classList.contains("markupNode")){
               this.state.elementUnderCaret = element.getAttribute("name")
            }
            this.updateMarkupButtons()
         },

         onSelectionStart(evt){
            this.state.selectionInComponent = this.root.contains(evt.target)
         },

         onEditableDivKeyDown(evt){
            if(evt.keyCode == 13 && !evt.shiftKey){
               evt.preventDefault()
            }
         },

         onEditableDivKeyUp(evt){
            this.onKeyUp(evt)
            this.onCaretPositionChange()
         },

         onEditableDivClick(evt){
            this.onCaretPositionChange()
         },

         onEditableDivInput(evt){
            this.onCaretPositionChange()
         },

         onEditableDivFocus(evt){
            this.state.focused = true
            this.updateMarkupButtons()
         },

         onEditableDivBlur(evt){
            this.state.focused = false
            this.updateMarkupButtons()
         },

         onKeyUp(evt){
            evt.stopPropagation()
            if(evt.keyCode == 13 && !evt.shiftKey && !evt.ctrlKey && !evt.metaKey){
               this.changeValue()
            } else if(evt.keyCode == 27){
               this.nvhStore.stopElementEditing()
            }
         },

         onSelectChange(evt){
            this.nvhStore.changeElementValue(this.props.element, evt.target.value)
         },

         onBoolChange(evt){
            this.nvhStore.changeElementValue(this.props.element, evt.target.value)
         },

         getValueForEditor(){
            let value = this.props.element.value.replace(/\\n/g, "<br>")
            return this.nvhStore.replaceMarkupOccurrences(value, this.props.element, this.getElementMarkupHTML.bind(this))
         },

         getMarkupNumber(elementName){
            return this.state.markupChildrenNames.lastIndexOf(elementName) + 1
         },

         getElementMarkupHTML(elementName, value=""){
            return `<span name="${elementName}" class="markupNode" markup_number="${this.getMarkupNumber(elementName)}" style="--bullet-background-color:${this.nvhStore.getElementColor(elementName)}">${value}</span>`
         },

         getElementUnderCaret(){
            let selection = window.getSelection()
            if(selection.rangeCount){
               let range = selection.getRangeAt(0)
               let startContainer = range.startContainer
               // If the startContainer is a text node, get its parent element
               let element = startContainer.nodeType === Node.TEXT_NODE ? startContainer.parentElement : startContainer
               // Check if the element is within the editable div
               if ($(element).closest(".nvh-editable-div")) {
                  return element
               }
            }
            return null
         },

         selectWordUnderCaret(){
            const selection = window.getSelection()
            if (!selection.rangeCount) {
               return null
            }
            const range = selection.getRangeAt(0)
            const node = range.startContainer

            if (node.nodeType !== Node.TEXT_NODE){
               return null
            }
            const text = node.textContent
            const startOffset = range.startOffset

            if(!(text[startOffset] || "").trim()){
               return null
            }
            // Find word boundaries
            let start = startOffset
            let end = startOffset
            while (start > 0 && !/[\s\.,\?!:;—\-\(\)\[\]\{\}"']/.test(text[start - 1])) {
               start--
            }
            while (end < text.length && !/[\s\.,\?!:;—\-\(\)\[\]\{\}"']/.test(text[end])) {
               end++
            }
            const wordRange = document.createRange()
            wordRange.setStart(node, start)
            wordRange.setEnd(node, end)

            selection.removeAllRanges()
            selection.addRange(wordRange)
         },

         handleMouseDownOutside(evt){
            if(!this.root.contains(evt.target)){
               this.changeValue()
            }
         },

         updateMarkupButtons(){
            this.state.markupChildrenNames.forEach(markupElementName => {
               $(`.btn[name="btn_${markupElementName}"]`, this.root)
                     .toggleClass("selected", this.state.focused && this.state.elementUnderCaret == markupElementName)
                     .toggleClass("disabled", this.state.elementUnderCaret != markupElementName
                              && (this.state.markupElementInSelection || !!this.state.elementUnderCaret))
            })
         },

         changeValue(){
            if(this.state.showEditor){
               let div = document.createElement("div")
               div.innerHTML = $(".nvh-editable-div").html().replaceAll("<br>", "\\n")
               let value = div.textContent || div.innerText || ""
               this.updateMarkupChildren()
               this.nvhStore.validateAllElements()
               this.nvhStore.changeElementValue(this.props.element, value.trim())
            } else{
               this.nvhStore.changeElementValue(this.props.element, $(".nvh-select, .nvh-input").first().val().trim())
            }
            if(this.nvhStore.findElements(e => e.edit).includes(this.props.element)){
               this.nvhStore.stopElementEditing()
            }
         },

         updateMarkupChildren(){
            this.state.markupChildrenNames.forEach(elementName => {
               this.props.element.children = this.props.element.children.filter(child => child.name != elementName)
               const markupElements = $(".nvh-editable-div").find(`span[name="${elementName}"]`)
               markupElements.each((idx, el) => {
                  let markupValue = el.textContent
                  let preceedingText = window.getElementPreceedingText(el)
                  let childElement = this.nvhStore._addChildElement(this.props.element, elementName)
                  childElement.value = markupValue
                  preceedingValueCount = Array.from(preceedingText.matchAll(window.reEscape(markupValue))).length
                  if(preceedingValueCount){
                     childElement.value += `#${preceedingValueCount + 1}`
                  }
               })
            })
         },

         initFormSelect(){
            if(this.state.config.type == "list"){
               window.initFormSelects(this.root)
            }
         },

         focusInput(){
            if(this.props.element.edit && this.state.config.type != "bool"){
               let el = $(this.state.showEditor ? ".nvh-editable-div" : "input, textarea", this.root).first().focus()
               window.scrollToTheEndOfInput(el)
            }
         }
      }
   </script>

   <style type="scss">
      :host{
         display: block;
         min-width: 200px;
         &.nvh-full-width{
            width: 100%;
         }
         &.nvh-item-value-editor{
            .select-wrapper input{
               width: auto;
               display: inline-block;
               background-color: white;
               padding: 4px 8px;
               height: auto;
               height: 22px;
               line-height: 22px;
               margin: 0;
            }
            .select-wrapper{
               display: inline-block;
            }
            .select-wrapper .caret{
               z-index: 1;
               pointer-events: none;
            }
         }
      }
      .markupBtn.btn{
         transition: none;
         height: 20px;
         line-height: 20px;
         margin: 5px 4px 0;
         border-radius: 2px;
         padding: 0px 5px;
         text-transform: none;
         font-size: 0.8em;
         background-color: #343434;
         &:hover{
            background-color: var(--background-color);
         }
         &.selected{
            background-color: var(--background-color);
         }
      }
      .nvh-text-value{
         border: 1px solid grey;
         display: block;
         background-color: #fff;
         position: relative;
         /* reset possible element styles */
         font-size: 1rem;
         font-weight: normal;
         font-style: normal;
         .nvh-editable-div{
            padding: 5px 8px 25px;
            min-height: 50px;
            outline: none;
            b {
               font-weight: normal;
            }
            i {
               font-style: normal;
            }
            u {
               text-decoration: none;
            }
            img {
               display: none;
            }
            .markupNode{
               position: relative;
               padding-left: 16px;
               padding-right: 2px;
               &:hover{
                  border-bottom: 1px solid var(--bullet-background-color);
               }
               &::before{
                  content: attr(markup_number);
                  position: absolute;
                  left: 0px;
                  top: 3px;
                  display: inline-block;
                  background-color: var(--bullet-background-color);
                  color: #fff;
                  border-radius: 5px;
                  height: 14px;
                  width: 14px;
                  text-align: center;
                  line-height: 14px;
                  font-size: 12px;
               }
               &::after{
                  content: '';
                  position: absolute;
                  left: 0px;
                  right: 0px;
                  top: 2px;
                  bottom: 2px;
                  background-color: var(--bullet-background-color);
                  opacity: 0.1;
                  border-radius: 5px;
                  pointer-events:none;
               }
            }
         }
         .nvh-save-note{
            position: absolute;
            left: 8px;
            bottom: 0px;
         }
         .nvh-toolbar{
            display: flex;
            direction: ltr;
            background-color: whitesmoke;
            border-bottom: #d9d9d8;
            position: sticky;
            width: 100%;
            top: 0;
            z-index: 999;
            i{
               color: grey;
               cursor: pointer;
               display: inline-block;
               width: 35px;
               height: 30px;
               line-height: 30px;
               text-align: center;
               font-size: 22px;
               padding: 0;
               &:hover{
                  background-color: #cccccc;
               }
               &.active{
                  color: black;
                  box-shadow: none;
               }
               &.disabled{
                  pointer-events: none;
                  opacity: 0.3
               }
               &.icon-close{
                  margin-left: auto;
                  border-left: 1px solid #d9d9d8;
               }
            }
         }
      }
   </style>
</nvh-item-value-editor>
