<nvh-editor class="positionRelative">
   <loading-overlay if={dictData.isEntryLoading}/>
   <nvh-editor-toolbar/>
   <nvh-revisions/>
   <template if={nvhData.entry}>
      <nvh-editor-context-menu/>
      <nvh-custom-editor if={nvhData.customEditor && dictData.editorMode != "code"}/>
      <template if={!nvhData.customEditor}>
         <template if={dictData.editorMode == "view"}>
            <nvh-element-style-editor if={dictData.userAccess.canEdit}/>
            <nvh-editor-item-toolbar if={dictData.userAccess.canEdit}/>
            <div class="nvh-editor-view-items {nvhData.revision ? 'pointerEventsNone' : ''}">
               <example-section-item if={window.nvhFormattingEditor.currentLayout !== null}
                  schema={window.nvhFormattingEditor.currentLayout.schema.children[0]}
                  entry={nvhData.entry}
                  isFormatting={false}
                  bulletIndex={1}
                  maxPossibleWidth={window.nvhFormattingEditor.getMaxPossibleWidth()}/>
               <!--<nvh-editor-view-item element={nvhData.entry}
                     read-only={!dictData.userAccess.canEdit || !!nvhData.revision}/>-->
            </div>
         </template>
         <template if={dictData.editorMode == "edit"}>
            <nvh-custom-editor if={nvhData.customEditor}/>
            <nvh-side-dnd-panel if={dictData.userAccess.canEdit}/>
            <nvh-widget-panel/>
            <div if={!nvhData.customEditor}
                  class="nvh-editor-edit-items {nvhData.revision ? 'pointerEventsNone' : ''}">
               <nvh-editor-edit-item element={nvhData.entry}
                     read-only={!dictData.userAccess.canEdit || !!nvhData.revision}/>
            </div>
         </template>
      </template>
   </template>
   <nvh-source-code if={(nvhData.entry || nvhData.brokenEntryNvh) && dictData.editorMode == "code"}
         read-only={!dictData.userAccess.canEdit}/>
   <template if={!dictData.isEntryLoading && !nvhData.entry && dictData.editorMode != "code"}>
      <template if={!nvhData.brokenEntryNvh}>
         <div class="nvh-entry-status grey-text">
            <div class="nvh-entry-status-title mb-2">
               NO ENTRY SELECTED
            </div>
            <div class="nvh-entry-status-desc">
               Select an entry from the side menu<template if={dictData.userAccess.canEdit}> or create a <a href="javascript:void(0);" onclick={onCreateNewEntryClick}>new one</a></template>.
            </div>
         </div>
      </template>
      <template if={nvhData.brokenEntryNvh}>
         <div class="nvh-entry-status grey-text">
            <div class="nvh-entry-status-title mb-2">
               ENTRY IS BROKEN
            </div>
            <div if={nvhStore.getAvailableActions().code}
                  class="nvh-entry-status-desc">
               You can fix the entry in the <a href="javascript:void(0);" onclick={onOpenCodeEditorClick}>code editor</a>.
            </div>
         </div>
      </template>
   </template>


   <script>
      export default{
         bindings: [["store", "isEntryLoadingChanged", "onIsEntryLoadingChanged"],
                    ["nvhStore", "revisionChanged", "update"],
                    ["nvhStore", "entryContentChanged", "onEntryContentChanged"],
                    ["nvhStore", "editorModeChanged", "onEditorModeChanged"]],


         onBeforeMount(){
            this.nvhStore = window.nvhStore
            this.nvhData = this.nvhStore.data
            this.nvhFormattingEditor = window.nvhFormattingEditor
            window.addEventListener("resize", this.isLayoutSchemaChange);
         },

         onMounted(){
            this.refreshListeners()
            if(this.dictData.config.formatting.customCss){
               window.CustomStyles.add("nvhEditorCustomStyles", this.dictData.config.formatting.customCss, ".nvh-editor-view-items")
            }
            if (this.dictData.config.formatting.layout === undefined || this.dictData.config.formatting.layout === null) {
               /* Display only entry name, because no layout is defined */
               this.nvhFormattingEditor.initializeSchemas();
            } else {
               /* Load layouts from DB*/
               this.nvhFormattingEditor.layout = this.dictData.config.formatting.layout;
            }
            this.nvhFormattingEditor.currentLayout = this.nvhFormattingEditor.layout.desktop;
            this.isLayoutSchemaChange();
         },

         onBeforeUnmount(){
            this.removeEventListeners()
             window.CustomStyles.remove("nvhEditorCustomStyles")
             window.removeEventListener("resize", this.isLayoutSchemaChange);
         },

         isLayoutSchemaChange() {
            let oldLayout = this.nvhFormattingEditor.data.activeLayout;
            this.nvhFormattingEditor.changeLayoutSchema();
            let newLayout = this.nvhFormattingEditor.data.activeLayout;
            if (oldLayout !== newLayout) {
               this.update();
            }
         },

         onIsEntryLoadingChanged(){
            this.update()
            this.refreshListeners()
         },

         onEditorModeChanged(){
            this.update()
            this.refreshListeners()
         },

         onEntryContentChanged(){
            // update URL here not in store, so changing entryId in other part
            // of lexonomy does not trigger URL update
            this.nvhStore.updateUrl()
            this.update()
         },

         onCreateNewEntryClick(){
            this.nvhStore.createNewEntry()
         },

         onOpenCodeEditorClick(){
            this.nvhStore.changeEditorMode("code")
         },

         handleClickOutside(evt){
            if(this.root.contains(evt.target)){
               $(this.root).addClass("focused")
               $("dict-edit").removeClass("focused")
            }
         },

         onKeyDown(evt){
            let key = evt.keyCode
            let ctrl = evt.ctrlKey || evt.metaKey
            let alt = evt.altKey
            let shift = evt.shiftKey
            let actions = this.nvhStore.getAvailableActions()
            if (evt.key == "1"){
               if(!ctrl && alt && !shift && actions.view){
                  evt.preventDefault()
                  this.nvhStore.changeEditorMode("view")
               }
            } else if (evt.key == "2"){
               if(!ctrl && alt && !shift && actions.edit){
                  evt.preventDefault()
                  this.nvhStore.changeEditorMode("edit")
               }
            } else if (evt.key == "3"){
               if(!ctrl && alt && !shift && actions.code){
                  evt.preventDefault()
                  this.nvhStore.changeEditorMode("code")
               }
            } else if(key == 13){  // enter
               ctrl && !alt && !shift && this.saveEntryAndGoToNext(evt)
            } else if(evt.key == "n"){  // n
               !ctrl &&  alt && !shift && actions.new && this.nvhStore.callIfNoNeedToSave(() => {
                  this.nvhStore.createNewEntry()
               })
            } else if(key == 83){  // s
               if(ctrl && !alt && !shift){
                  evt.preventDefault()
                  this.saveEntry()
               }
            }
            if(key == 38 || key == 40){  // up, down
               alt && window.nvhStore.callIfNoNeedToSave(() => {
                  let nextEntry = this.dictData.entryList[this.dictData.entryList.findIndex(e => e.id == this.dictData.entryId) + (key == 38 ? -1 : 1)]
                  nextEntry && this.store.changeEntryId(nextEntry.id)
               })
               if(!["TEXTAREA", "INPUT"].includes(evt.target.nodeName)
                  && evt.target.contentEditable != 'true'
                  && evt.target.contentEditable != 'plaintext-only'){
                  // prvent screen from scrolling
                  evt.preventDefault()
               }
            }
            if(evt.target?.parentNode.classList.contains("select-dropdown")){
               // User hit enter when selecting value in select dropdown. Prevent
               // processing of next onkeyup, which would open dropdown again
               // TODO: try to find better solution, modification of event in dropdown keyup did not work
               this.state.ignoreNextKeyUp = true
            }
            let focused = this.nvhStore.getFocusedElement()
            if(focused
                  && $(this.root).hasClass("focused")
                  && !this.nvhData.isContextMenuOpen
                  && !focused.edit
                  && !["TEXTAREA", "INPUT"].includes(evt.target.nodeName)){
               if(key == 38){ // arrow up
                  !ctrl && !alt && !shift && this.nvhStore.goToPrevElement()
                   ctrl && !alt && !shift && this.nvhStore.moveElementUp(focused)
                   ctrl && !alt &&  shift && this.nvhStore.moveElementToPreviousParent(focused)
               } else if(key == 40){ // arrow down
                  !ctrl && !alt && !shift && this.nvhStore.goToNextElement()
                   ctrl && !alt && !shift && this.nvhStore.moveElementDown(focused)
                   ctrl && !alt &&  shift && this.nvhStore.moveElementToNextParent(focused)
               } else if(key == 39){ // arrow right
                  if(!ctrl && !alt){
                     if(focused.children.length && focused.collapsed){
                        this.nvhStore.expandElement()
                     } else {
                        this.nvhStore.goToNextElement()
                     }
                  }
               } else if(key == 37){ // arrow left
                  if(!ctrl && !alt){
                     if((focused.collapsed || !focused.children.length) && focused.parent){
                        this.nvhStore.focusElement(focused.parent)
                     } else {
                        this.nvhStore.collapseElement()
                     }
                  }
               }
            }
         },

         onKeyUp(evt){
            if(this.state.ignoreNextKeyUp){
               this.state.ignoreNextKeyUp = false
               return
            }
            let key = evt.keyCode
            let alt = evt.altKey
            let shift = evt.shiftKey
            let ctrl = evt.ctrlKey || evt.metaKey
            let focused = this.nvhStore.getFocusedElement()
            if(focused
                  && $(this.root).hasClass("focused")
                  && !this.nvhData.isContextMenuOpen
                  && !focused.edit){
               if (key == 13){  // enter
                  !ctrl && !alt && !shift && this.nvhStore.startElementEditing(focused)
                  !ctrl && !alt &&  shift && this.nvhStore.trigger("openContextMenu")
               } else if (key == 45){  // insert
                   ctrl && !alt && !shift && this.nvhStore.isElementDuplicationAllowed(focused) && this.nvhStore.duplicateElement(focused)
               } else if (key == 46) {  //delete
                   ctrl && !alt && !shift && this.nvhStore.isElementRemovalAllowed(focused) && this.nvhStore.removeElement(focused)
               }
            }
         },

         saveEntry(){
            if(this.nvhData.customEditor || this.nvhStore.isValid()){  // do not validate if custom editting wiget is used
               if(this.nvhStore.hasEntryChanged() && this.nvhStore.getAvailableActions().save){
                  return this.nvhStore.saveEntry()
               }
            } else {
               M.toast({html: "Cannot save an invalid entry."})
            }
            return false
         },

         saveEntryAndGoToNext(evt){
            evt.preventDefault()
            let saveRequest = this.saveEntry()
            if(saveRequest){
               saveRequest.done(response => {
                  if(response.success){
                     this.goToNextEntry()
                  }
               })
            } else if(!this.nvhStore.hasEntryChanged()){
               this.goToNextEntry()
            }
         },

         goToNextEntry(){
            let idx = this.dictData.entryList.findIndex(e => e.id == this.dictData.entryId)
            if(this.dictData.entryList[idx + 1]){
               this.store.changeEntryId(this.dictData.entryList[idx + 1].id)
            }
         },

         refreshListeners(){
            this.removeEventListeners()
            this.addEventListeners()
         },

         addEventListeners(){
            if(this.nvhData.entry){
               document.addEventListener('keydown', this.onKeyDown)
               if(this.dictData.editorMode == "edit"){
                  document.addEventListener('click', this.handleClickOutside)
                  document.addEventListener('keyup', this.onKeyUp)
               }
            }
         },

         removeEventListeners(){
            document.removeEventListener('keyup', this.onKeyUp)
            document.removeEventListener('click', this.handleClickOutside)
            document.removeEventListener('keydown', this.onKeyDown)
         }
      }
   </script>

   <style type="scss">
      :host{
         min-height: 400px;
         display: block;
      }
      .nvh-entry-status{
         min-height: 50vh;
         text-align: center;
         padding-top: 20vh;
      }
      .nvh-entry-status-title{
         margin-top: -30px;
         font-size: 30px;
      }
      .nvh-editor-edit-items {
         margin-left: 20px;
         padding-right: 80px; // make sure there is space for row action icons
      }
   </style>
</nvh-editor>
