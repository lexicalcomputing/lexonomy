<dict-config-formatting>
  <h1 class="formatting-page-title">Entry Formatting</h1>
  <div class="formatting-page-visibility-container">
    <div onclick={onLayoutClick.bind(this, "showElements")}
        class="formatting-page-visibility-item {!state.showElements ? "item-inactive" : ""}">
      <i class="small material-icons">sort</i>
    </div>
    <div onclick={onLayoutClick.bind(this, "showStyle")}
        class="formatting-page-visibility-item {!state.showStyle ? "item-inactive" : ""}">
      <i class="small material-icons">format_paint</i>
    </div>
    <div onclick={onLayoutClick.bind(this, "showEditing")}
        class="formatting-page-visibility-item {!state.showEditing ? "item-inactive" : ""}">
      <i class="small material-icons">edit</i>
    </div>
    <div onclick={onLayoutClick.bind(this, "showExample")}
        class="formatting-page-visibility-item {!state.showExample ? "item-inactive" : ""}">
      <i class="small material-icons">view_compact</i>
    </div>
  </div>
  <div class="formatting-page-wrapper-container">
    <div if={state.showElements}
        id="elements-container"
        class="formatting-page-container">
      <div class="header-box">
        <i class="small material-icons">sort</i>
        <h2>Elements</h2>
        <div id="trash-icon-wrapper"
            ondragenter={onDragEnter}
            ondragleave={onDragLeave}
            ondragover={onDragOver}
            ondrop={onDrop}>
          <i class="small material-icons trash-disabled" id="trash-icon">delete</i>
        </div>
      </div>
      <div class="elements-choice-section-wrapper">
        <elements-choice-section class="elements-choice-section"
                                parent={this}
                                global={global}
                                elementsSchema={elementsSchema}/>
      </div>
    </div>
    <div if={state.showStyle}
        id="style-container"
        class="formatting-page-container">
      <div class="header-box">
        <i class="small material-icons">format_paint</i>
        <h2>Style</h2>
      </div>
      <div>TBD</div>
    </div>
    <div if={state.showEditing}
        id="editing-container"
        class="formatting-page-container">
      <div class="editing-header">
        <div class="header-box">
          <i class="small material-icons">edit</i>
          <h2>Editing</h2>
          <div id="buttons-box">
            <div id="undo-icon-wrapper"
                onclick={undoSchema}>
              UNDO
            </div>
            <div id="redo-icon-wrapper"
                onclick={redoSchema}>
              REDO
            </div>
            <div class="horizontal-filler"></div>
            <div id="reset-icon-wrapper"
                onclick={resetSchema}>
              RESET
            </div>
          </div>
        </div>
      </div>
      <div class="editing-layout-wrapper">
        <edit-layout class="edit-layout"
                    editing={state.editing}
                    schema={schema}
                    parent={this}
                    close-action-panel={closeActionPanel}
                    global={global}/>
      </div>
    </div>
    <div if={state.showExample} 
        id="example-container"
        class="formatting-page-container">
      <div class="header-box">
        <i class="small material-icons">view_compact</i>
        <h2>Example</h2>
      </div>
      <div class="example-section-wrapper">
        <example-section class="example-section"
                        schema={schema}/>
      </div>
    </div>
  </div>
  
  <script>
    export default {
      state: {
        showElements: true,
        showStyle: false,
        showEditing: true,
        showExample: true,
        editing: {
          enabled: true,
          mode: "column" /*types: "column", "row", "delete" */
        },
      },
      global: null,
      schema: {
        orientation: "column", /*orientation of scrollable-div is always "column"*/
        children: [
          {
            status: {
              isActive: false, /*action panel is displayed*/
              isHovered: false,
            },
            orientation: "column", /*default placeholder is of type "column"*/
            type: "placeholder",
            content: {
              name: "",
              fullName: "",
              area: "",
              areaFullName: "",
              color: "",
              canHaveChildren: true,
            },
            contentColor: "", /*TODO: probably remove*/
            children: [],
          }
        ]
      },
      schemaHistory: null,
      schemaHistoryIndex: null,
      elementsSchema: null,

      onBeforeMount() {
        this.elementsSchema = this.createElementsSchema(window.store.schema.getRoot());
        this.global = {
          canBeRemovedIfHovered: true, /*remove only the deepest hovered "placeholder", the other ones should stay as they are*/
          canBeDropped: true, /*drop element only to deepest hovered "placeholder"*/
          canBeDragged: true, /*drag only the deepest hovered "placeholder"*/
          draggedElementFullName: "",
          draggedPlaceholder: null,
          dropInfo: {
            wasSuccessful: false,
            index: null,
          },
          canOpenActionPanel: true, /*open only action panel of the deepest hovered "placeholder"*/
          selectedPlaceholderAreaFullName: "",
          parent: null,
        };
        this.schema.children[0].content = {
          name: "entry",
          fullName: "entry",
          area: "entry",
          areaFullName: "entry",
          color: window.nvhStore.getElementColor("entry"),
          canHaveChildren: true,
        };
        this.schemaHistory = [JSON.parse(JSON.stringify(this.schema))];
        this.schemaHistoryIndex = 0;
      },
      onBeforeUpdate() {
        this.elementsSchema = this.createElementsSchema(window.store.schema.schema);
        this.global = {
          canBeRemovedIfHovered: true,
          canBeDropped: true,
          canBeDragged: true,
          draggedElementFullName: this.global.draggedElementFullName,
          draggedPlaceholder: this.global.draggedPlaceholder,
          dropInfo: {
            wasSuccessful: false,
            index: null,
          },
          canOpenActionPanel: true,
          schemaHistoryIndex: this.schemaHistoryIndex,
          selectedPlaceholderAreaFullName: this.global.selectedPlaceholderAreaFullName,
          parent: null,
        };
        /*
        Change history, if I modified edit section in other way that using 'undo' or 'redo'.
        */
        if (this.isSchemaChanged(this.schemaHistory.at(this.schemaHistoryIndex), this.schema)) {
          this.schemaHistory.length = this.schemaHistoryIndex + 1;
          this.schemaHistory.push(JSON.parse(JSON.stringify(this.schema)));
          this.schemaHistoryIndex += 1;
        }
      },

      onDragEnter() {
        const rawData = event.dataTransfer.getData("text/plain");
        const data = JSON.parse(rawData);
        if (data.type === "elementholder-label") {
          let trashIcon = document.getElementById("trash-icon");
          trashIcon.classList.add("trash-dragged-over");
        }
      },
      onDragLeave() {
        let trashIcon = document.getElementById("trash-icon");
        trashIcon.classList.remove("trash-dragged-over");
      },
      onDragOver(event) {
        event.preventDefault();
      },
      onDrop() {
        this.global.dropInfo.wasSuccessful = true;
        this.closeActionPanel();
        this.global.selectedPlaceholderAreaFullName = "";
        let trashIcon = document.getElementById("trash-icon");
        trashIcon.classList.remove("trash-dragged-over");
      },

      onLayoutClick(sectionName) {
        this.update({[sectionName]: !this.state[sectionName]});
      },
      onToggleEditing() {
        this.state.editing.enabled = !this.state.editing.enabled;
        this.update();
      },
      onEditModeChange(editModeType) {
        this.state.editing.mode = editModeType;
        this.update();
      },
      /*
      TODO: figure out how to call this only after onMounted is called.
      The problem is that I need to refresh "edit" and "example" section, but "elements"
      section should remain the same.
      */
      createElementsSchema(element) {
        let objectStructure = {
          data: {
            type: "choice-item",
            name: element.name,
            fullName: element.path,
            color: window.nvhStore.getElementColor(element.path),
            children: [],
          },
        };
        for (let child of element.children) {
          let newElement = this.createElementsSchema(child);
          objectStructure.data.children.push(newElement)
        }
        return objectStructure;
      },
      resetSchema() {
        this.schema = {
          orientation: "column",
          children: [
            {
              status: {
                isActive: false,
                isDragged: false,
              },
              orientation: "column",
              type: "placeholder",
              content: {
                name: "entry",
                fullName: "entry",
                area: "entry",
                areaFullName: "entry",
                color: window.nvhStore.getElementColor("entry"),
                canHaveChildren: true,
              },
              contentColor: "",
              children: [],
            }
          ]
        },
        this.global.selectedPlaceholderAreaFullName = "";

        this.update();
      },
      undoSchema() {
        if (this.schemaHistoryIndex > 0) {
          this.schemaHistoryIndex -= 1;
          this.schema = JSON.parse(JSON.stringify(this.schemaHistory.at(this.schemaHistoryIndex)));
          this.clearStatuses(this.schema);
          this.global.selectedPlaceholderAreaFullName = "";
          this.update();
        }
      },
      redoSchema() {
        if (this.schemaHistoryIndex < this.schemaHistory.length - 1) {
          this.schemaHistoryIndex += 1;
          this.schema = JSON.parse(JSON.stringify(this.schemaHistory.at(this.schemaHistoryIndex)));
          this.clearStatuses(this.schema);
          this.global.selectedPlaceholderAreaFullName = "";
          this.update();
        }
      },
      isSchemaChanged(oldSchema, newSchema) {
        if (oldSchema.orientation !== newSchema.orientation) {
          return true;
        }
        if (oldSchema.content !== undefined && oldSchema.content !== undefined) {
          if (oldSchema.content.fullName !== newSchema.content.fullName) {
            return true;
          }
          if (oldSchema.content.fullName !== newSchema.content.fullName) {
            return true;
          }
        }
        if (oldSchema.children.length !== newSchema.children.length) {
          return true;
        }

        for (let i = 0; i < newSchema.children.length; i++) {
          if (this.isSchemaChanged(oldSchema.children.at(i), newSchema.children.at(i))) {
            return true;
          }
        }

        return false;
      },
      clearStatuses(state) {
        if (state === null) {
          return;
        }
        Array.from(state.children).map(child => this.clearStatuses(child));
        state.children.map(child => {
          child.status.isActive = false;
          child.status.isHovered = false;
          child.status.isDragged = false;
        });
      },
      closeActionPanel() {
        this.closeActionPanelRec(this.schema);
      },
      closeActionPanelRec(state) {
        if (state === null) {
          return null;
        }
        Array.from(state.children).map(child => this.closeActionPanelRec(child));
        state.children.map(child => child.status.isActive = false);
      },
    }
  </script>

  <style>
    * {
      --color-row:rgb(241, 137, 113);
      --color-column:rgb(121, 195, 245);
      --color-can-be-dropped: rgb(237, 205, 116);
      --color-is-dragged-over: rgb(162, 127, 31);
      --color-is-dragged-over-light: rgb(255, 245, 217);
      --color-is-active: rgb(21, 93, 225);
      --color-is-hovered: rgb(132, 155, 237);
    }


    .scrollable-div {
      position: relative;
      display: flex;
      flex-direction: column;
      min-width: 450px;
      width: fit-content;
      height: 100%;
      overflow: auto;
      min-width: 100%;
      padding: 5px;
    }
    .icon-svg {
      height: 20px;
      width: 20px;
    }
    .header-box {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    #trash-icon-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .trash-disabled {
      color: rgb(176, 192, 205);
      cursor: not-allowed;
    }
    .trash-enabled {
      color: black;
    }
    .trash-dragged-over {
      transform: scale(1.1);
      color: red;
    }

    #buttons-box {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      padding: 2px;
      background-color: rgb(240, 247, 246)
    }

    #reset-icon-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid black;
      padding: 2px 4px;
      background-color: rgb(232, 108, 102);
    }
    #reset-icon-wrapper:hover {
      transform: scale(1.05);
      background-color: rgb(240, 94, 87);
      cursor: pointer;
    }
    #reset-icon-wrapper:active {
      transform: scale(1.1);
    }

    #undo-icon-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid black;
      padding: 2px 4px;
      background-color: rgb(166, 227, 240);
    }
    #undo-icon-wrapper:hover {
      transform: scale(1.05);
      background-color: rgb(147, 219, 235);
      cursor: pointer;
    }
    #undo-icon-wrapper:active {
      transform: scale(1.1);
    }

    #redo-icon-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid black;
      padding: 2px 4px;
      background-color: rgb(166, 240, 202);
    }
    #redo-icon-wrapper:hover {
      transform: scale(1.05);
      background-color: rgb(146, 235, 189);
      cursor: pointer;
    }
    #redo-icon-wrapper:active {
      transform: scale(1.1);
    }

    .horizontal-filler {
      width: 300px;
    }


    .formatting-page-title {
      text-wrap: nowrap;
    }
    .formatting-page-visibility-container {
      display: flex;
    }
    .formatting-page-wrapper-container {
      display: flex;
      height: 700px;
      overflow-x: auto;
    }


    .elements-choice-section {
      width: fit-content;
      display: block;
      height: 100%;
      min-width: 100%;
    }
    .elements-choice-section-wrapper {
      width: 100%;
      height: 600px;
    }


    .example-section {
      width: fit-content;
      display: block;
      height: 100%;
      min-width: 100%;
    }
    .example-section-wrapper {
      min-width: 600px;
      height: 600px;
    }


    .formatting-page-visibility-item {
      padding: 5px;
      background-color: #40e675;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .formatting-page-visibility-item:hover {
      cursor: pointer;
      background-color:rgb(32, 214, 90);
      transform: scale(1.05);
    }
    .formatting-page-visibility-item:active {
      transform: scale(1.1);
    }
    .item-inactive {
      background-color: #d3e8d9;
    }


    .formatting-page-container {
      width: 100%;
    }
    #elements-container {
      border-right: 1px solid #dcdee3;
      padding-right: 1.5em;
      flex: 2 5 auto;
      min-width: 220px
    }
    #style-container {
      border-right: 1px solid #dcdee3;
      padding-left: 1.5em;
      padding-right: 1.5em;
      flex: 1 6 auto;
      min-width: 150px;
    }
    #editing-container {
      border-right: 1px solid #dcdee3;
      padding-left: 1.5em;
      padding-right: 1.5em;
      flex: auto;
      width: auto;
    }
    #example-container {
      border-right: 1px solid #dcdee3;
      padding-left: 1.5em;
      padding-right: 1.5em;
      flex: auto;
      width: auto;
    }


    .editing-header {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 600px;
    }
    .editing-layout-wrapper {
      width: 100%;
      height: 600px;
    }
    .edit-layout {
      width: fit-content;
      display: block;
      height: 100%;
      min-width: 100%;
    }
  </style>
</dict-config-formatting>