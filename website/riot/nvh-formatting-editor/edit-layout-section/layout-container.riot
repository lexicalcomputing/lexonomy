<layout-container>
   <action-panel if={!nvhFormattingEditor.data.mouseData}
      class="action-panel
            {this.nvhFormattingEditor.isLayoutContainerHovered(props.state) ? "action-panel-hovered" : ""}"
      index={props.index}
      parentState={props.parentState}
      state={props.state}
      isBaseLevel={props.isBaseLevel}/>
   <elementholder-component class="elementholder"
      state={props.state}
      canHaveAdders={props.canHaveAdders}
      isBaseLevel={props.isBaseLevel}/>
   <add-children-component getBackgroundColor={getBackgroundColor}
      class="add-children-component"
      state={props.state}
      canHaveAdders={props.canHaveAdders}>
   </add-children-component>
   <div class={getLayoutContainerInsideWrapperCssClass(props.state)}
      style="background-color: {getBackgroundColor()};
         border: 2px solid {getBorderColor()}">
      <adder-component if={props.canHaveAdders && !this.nvhFormattingEditor.isLayoutContainerDragged(props.state)
            && nvhFormattingEditor.isChildOfParent(props.state.content.areaFullName)}
         onclick={() => nvhFormattingEditor.addElement(0, props.state, null)}
         onmouseenter={onAdderMouseEnter}
         onmouseleave={onAdderMouseLeave}
         onmouseup={(event) => onAdderMouseUp(event, props.state, 0)}
         class={getAdderCssClass(props.state, "first")}
         orientation={props.state.children.length === 0 ? "column": props.state.orientation}
         index={0}
         state={props.state}/>
      <template each={(child, index) in props.state.children}>
         <layout-container onclick={() => nvhFormattingEditor.selectLayoutContainer(child, props.state)}
            title={nvhFormattingEditor.isElementNonExisting(child.content.fullName)
               ? "Entry structure changed, and element with path '" + child.content.fullName + "'' does not exist anymore. Remove it to fix the formatting structure." : ""}
            onmouseup={(event) => onMouseUp(event, child)}
            onmouseenter={(event) => onLayoutContainerMouseEnter(event, child)}
            onmouseleave={(event) => onLayoutContainerMouseLeave(event, child, props.state)}
            class={getLayoutContainerCssClass(child)}
            state={nvhFormattingEditor.childWithInheritedArea(child, props.state)}
            parentState={props.state}
            isBaseLevel={false}
            index={index}
            canHaveAdders={nvhFormattingEditor.canHaveAdders(props.state.content.areaFullName, child)}/>
         <adder-component if={props.canHaveAdders && !this.nvhFormattingEditor.isLayoutContainerDragged(props.state)
               && nvhFormattingEditor.isChildOfParent(props.state.content.areaFullName)}
            onclick={() => nvhFormattingEditor.addElement(index + 1, props.state, null)}
            onmouseenter={onAdderMouseEnter}
            onmouseleave={onAdderMouseLeave}
            onmouseup={(event) => onAdderMouseUp(event, props.state, index + 1)}
            class={getAdderCssClass(props.state, "other")}
            orientation={props.state.orientation}
            index={index + 1}
            state={props.state}/>
      </template>
   </div>

   <script>
      export default {
         onBeforeMount(props) {
         this.nvhFormattingEditor = window.nvhFormattingEditor;
         this.nvhStore = window.nvhStore;
         /* 
         Initialize labelStyles and markupStyles in case any of them is undefined
         this.props.state["markupStyles"].length === 0 is necessary because if someone change entry structure,
         markup styles will not appear in style section
         */
         if (!props.state.markupStyles.length) {
            let markupChildren = this.nvhFormattingEditor.getDirectMarkupChildren(props.state.content.fullName);
            if (markupChildren.length !== 0 ) {
               props.state.markupStyles = this.nvhFormattingEditor.createMarkupStyles(props.state.content.fullName);
            } else {
               props.state.markupStyles = [];
            }
         }
         props.state.labelStyles = props?.state?.labelStyles || {}
         props.state.bulletStyles = props?.state?.bulletStyles || {}
         props.state.type = "layout-container" // because of renaming from placeholder to layout container for backward compatibility
         },

         onBeforeUpdate(props) {
            props.state.type = "layout-container" // because of renaming from placeholder to layout container for backward compatibility
         },

         onMouseUp(event, state) {
            if (this.nvhFormattingEditor.data.canBeDropped) {
               const data = this.nvhFormattingEditor.data.mouseData;
               if (!data) {
                  return;
               }
               if (data.type === "choice-item") {
                  this.nvhFormattingEditor.data.selectedLayoutContainerParentAreaFullName = "";
                  if (this.nvhFormattingEditor.isElementWithoutChildrenToWrapper(data, state)
                        || this.nvhFormattingEditor.isElementToRedundantNestedWrapper(data, this.props.state.content.areaFullName, state)
                        || !this.nvhFormattingEditor.isChildOfParent(this.props.state.content.areaFullName)) {
                     this.nvhFormattingEditor.data.canBeDropped = false;
                     return;
                  }
                  for (let child of state.children) {
                     if (!this.nvhFormattingEditor.isParentLabelOfDropObject(data.fullName, child)
                           || this.nvhFormattingEditor.isLayoutContainerAsSameWrapper(data.fullName, child)) {
                        this.nvhFormattingEditor.data.canBeDropped = false;
                        return;
                     }
                  }
                  this.nvhFormattingEditor.fillLayoutContainerWithData(state, data);
               }
               if (data.releaseFunction) {
                  data.releaseFunction.run(...data.releaseFunction.parameters);
                  data.releaseFunction = null;
               }
               this.nvhFormattingEditor.data.canBeDropped = false;
            }
         },

         onAdderMouseEnter(event) {
            const data = this.nvhFormattingEditor.data.mouseData;
            if (data && data.type === "layout-container") {
               event.currentTarget.classList.add("adder-highligth-dragged");
            }
         },

         onAdderMouseLeave(event) {
            const data = this.nvhFormattingEditor.data.mouseData;
            if (data && data.type === "layout-container") {
               event.currentTarget.classList.remove("adder-highligth-dragged");
            }
         },

         onAdderMouseUp(event, state, index) {
            if (this.nvhFormattingEditor.data.canBeDropped) {
               const data = this.nvhFormattingEditor.data.mouseData;
               if (!data) {
                  return;
               }
               if (data.type === "layout-container") {
                  state.children.splice(index, 0, data);
                  this.nvhFormattingEditor.data.dropInfo.wasSuccessful = true;
                  this.nvhFormattingEditor.data.dropInfo.index = index;
                  this.nvhFormattingEditor.data.selectedLayoutContainerParentAreaFullName = "";
                  this.nvhFormattingEditor.data.canBeDropped = false;
               }
               if (data.releaseFunction) {
                  data.releaseFunction.run(...data.releaseFunction.parameters);
                  data.releaseFunction = null;
               }
               this.nvhFormattingEditor.data.hoveredLayoutContainer = null;
               this.nvhFormattingEditor.data.draggedLayoutContainer = null;
               this.update();
            }
         },

         onLayoutContainerMouseEnter(event, state) {
            if (!this.nvhFormattingEditor.data.mouseData) {
               event.currentTarget.classList.add("layout-container-mouse-hover");
               this.nvhFormattingEditor.data.hoveredLayoutContainer = state;
               this.nvhFormattingEditor.updateEditor();
            }
         },

         onLayoutContainerMouseLeave(event, state, parentState) {
            if (!this.nvhFormattingEditor.data.mouseData) {
               event.currentTarget.classList.remove("layout-container-mouse-hover");
               this.nvhFormattingEditor.data.hoveredLayoutContainer = null;
               /*
                  This is a work-around.
                  If I move a layoutContainer using arrows, sometimes I enter child layoutContainer
                  without entering parent layoutContainer. I need to assure that after leaving child layoutContainer,
                  the parent will be hovered which is expected behaviour.
               */
               const classList = Array.from(event.currentTarget.parentElement.parentElement.classList);
               if (classList.includes("layout-container")) {
                  event.currentTarget.parentElement.parentElement.classList.add("layout-container-mouse-hover");
                  this.nvhFormattingEditor.data.hoveredLayoutContainer = parentState;
               }
               this.nvhFormattingEditor.updateEditor();
            }
         },

         getBorderColor() {
            return !this.props.state.content.name ? "#c7ced1" : "transparent";
         },

         getBackgroundColor() {
            if (!this.props.state.content.name || this.props.isBaseLevel) {
               return "#ffffff";
            }
            if (this.props.state.children.length === 0) {
               return "transparent";
            }
            return this.nvhFormattingEditor.getColorLightVersion(this.nvhStore.getElementColor(this.props.state.content.fullName));
         },

         canBeDropped(state) {
            const data = this.nvhFormattingEditor.data.mouseData;
            if (!data || data.type !== "choice-item"
                  || this.nvhFormattingEditor.isElementWithoutChildrenToWrapper(data, state)
                  || this.nvhFormattingEditor.isElementToRedundantNestedWrapper(data, this.props.state.content.areaFullName, state)
                  || !this.nvhFormattingEditor.isChildOfParent(this.props.state.content.areaFullName)) {
               return false;
            }
            for (let child of state.children) {
               if (!this.nvhFormattingEditor.isParentLabelOfDropObject(data.fullName, child)
                  || this.nvhFormattingEditor.isLayoutContainerAsSameWrapper(data.fullName, child)) {
                  return false;
               }
            }
            return true;
         },

         getLayoutContainerCssClass(layoutContainer) {
            let cssClass = "layout-container";
            cssClass += this.nvhFormattingEditor.isLayoutContainerActive(layoutContainer) ? " layout-container-selected" : "";
            cssClass += this.nvhFormattingEditor.isLayoutContainerHovered(layoutContainer) && !this.nvhFormattingEditor.data.mouseData ? " layout-container-mouse-hover" : "";
            cssClass += layoutContainer.content.name && layoutContainer.children.length !== 0 ? " layout-container-wrapping-content" : "";
            cssClass += layoutContainer.children.length === 0 ? " layout-container-no-children" : "";
            cssClass += this.nvhFormattingEditor.isLayoutContainerDragged(layoutContainer) ? " layout-container-dragged" : "";
            cssClass += this.canBeDropped(layoutContainer) ? " layout-container-can-be-dropped" : "";
            cssClass += this.nvhFormattingEditor.isElementNonExisting(layoutContainer.content.fullName) ? " layout-container-non-existing" : "";
            return cssClass;
         },

         getLayoutContainerInsideWrapperCssClass(layoutContainer) {
            let cssClass = `layout-container-inside-wrapper layout-container-inside-wrapper-${layoutContainer.orientation}`;
            cssClass += !layoutContainer.content.fullName ? " layout-container-inside-wrapper-no-content" : "";
            cssClass += !layoutContainer.content.fullName && layoutContainer.children.length !== 0 ? " layout-container-inside-wrapper-group" : "";
            return cssClass;
         },

         getAdderCssClass(layoutContainer, adderType) {
            let cssClass = "adder"
            cssClass += !this.nvhFormattingEditor.data.mouseData || this.nvhFormattingEditor.data.mouseData.type === "layout-container" ? "" : " adder-invisible";
            if (adderType === "first") {
               cssClass += ` adder-${layoutContainer.children.length === 0 ? "column": layoutContainer.orientation}`;
               cssClass += layoutContainer.children.length === 0 ? " adder-alone" : "";
            } else {
               cssClass += ` adder-${layoutContainer.orientation}`;
            }
            return cssClass;
         } 
      }
   </script>

   <style>
      .layout-container-inside-wrapper {
         display: flex;
         align-items: center;
         justify-content: center;
         width: 100%;
         height: 100%;
      }
      .layout-container-inside-wrapper-column {
         flex-direction: column;
      }
      .layout-container-inside-wrapper-row {
         flex-direction: row;
      }
      .layout-container-wrapping-content {
         border: 4px solid transparent;
      }
      .layout-container-wrapping-content:has(.layout-container:hover) {
         border: 4px solid transparent;
      }
      .layout-container-no-content {
         padding: 10px;
      }
      .layout-container-dragged {
         opacity: 0.8;
      }
      .layout-container-dragged * {
         opacity: 0.8;
      }
      .layout-container-dragged .adder {
         display: none;
      }
      .adder-highligth {
         background-color: var(--color-can-be-dropped);
         padding: 5px !important;
         transition: all 500ms ease;
      }
      .adder-highligth .adder-line * {
         display: none;
      }
      .adder-highligth-dragged {
         background-color: var(--color-is-dragged-over) !important;
      }
      .adder-highligth-dragged .adder-line * {
         display: none;
      }
      .action-panel {
         display: none;
         position: absolute;
         top: -40px;
         left: -4px;
         z-index: 100;
      }
      .layout-container:has(.layout-container-mouse-hover) .action-panel-hovered {
         display: none;
      }
      .layout-container:not(:has(.layout-container-mouse-hover)) .action-panel-hovered {
         display: block;
      }
      .elementholder {
         width: fit-content;
         align-self: flex-start;
      }
      .add-children-component {
         width: 100%;
      }
      .adder-alone {
         padding: 0;
         margin: 15px;
      }
      .adder-invisible {
         visibility: hidden;
      }
      .layout-container-can-be-dropped {
         background-color: var(--color-is-dragged-over-light);
      }
      .layout-container-can-be-dropped > .layout-container-inside-wrapper {
         background-color: var(--color-is-dragged-over-light) !important;
      }
      .layout-container-can-be-dropped:hover {
         background-color:var(--color-yellow-light);
      }
      .layout-container-can-be-dropped:hover > .layout-container-inside-wrapper{
         background-color:var(--color-yellow-light) !important;
      }
      .layout-container-can-be-dropped:hover:has(.layout-container-can-be-dropped:hover) {
         background-color: var(--color-is-dragged-over-light);
      }
      .layout-container-can-be-dropped:hover:has(.layout-container-can-be-dropped:hover) > .layout-container-inside-wrapper {
         background-color: var(--color-is-dragged-over-light) !important;
      }
   </style>
</layout-container>