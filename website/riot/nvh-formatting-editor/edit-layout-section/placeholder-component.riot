<placeholder-component>
  <action-panel if={!nvhFormattingEditor.data.mouseData}
          class="action-panel
                {this.nvhFormattingEditor.isPlaceholderHovered(props.state) ? "action-panel-hovered" : ""}"
          index={props.index}
          parentState={props.parentState}
          state={props.state}
          isBaseLevel={props.isBaseLevel}/>
  <elementholder-component class="elementholder"
          state={props.state}
          canHaveAdders={props.canHaveAdders}
          isBaseLevel={props.isBaseLevel}/>
  <add-children-component getBackgroundColor={getBackgroundColor}
          class="add-children-component"
          state={props.state}
          canHaveAdders={props.canHaveAdders}>
  </add-children-component>
  <div class={getPlaceholderInsideWrapperCssClass(props.state)}
      style="background-color: {getBackgroundColor()};
            border: 2px solid {getBorderColor()}">
    <adder-component if={props.canHaveAdders && !this.nvhFormattingEditor.isPlaceholderDragged(props.state)
                        && nvhFormattingEditor.isChildOfParent(props.state.content.areaFullName)}
            onclick={() => nvhFormattingEditor.addElement(0, props.state, null)}
            onmouseenter={onAdderMouseEnter}
            onmouseleave={onAdderMouseLeave}
            onmouseup={(event) => onAdderMouseUp(event, props.state, 0)}
            class={getAdderCssClass(props.state, "first")}
            orientation={props.state.children.length === 0 ? "column": props.state.orientation}
            index={0}
            state={props.state}/>
    <template each={(child, index) in props.state.children}>
      <placeholder-component onclick={() => nvhFormattingEditor.selectPlaceholder(child, props.state)}
              title={nvhFormattingEditor.isElementNonExisting(child.content.fullName)
                    ? "Entry structure changed, and element with path '" + child.content.fullName + "'' does not exist anymore. Remove it to fix the formatting structure." : ""}
              onmouseup={(event) => onMouseUp(event, child)}
              onmouseenter={(event) => onPlaceholderMouseEnter(event, child)}
              onmouseleave={(event) => onPlaceholderMouseLeave(event, child, props.state)}
              class={getPlaceholderCssClass(child)}
              state={nvhFormattingEditor.childWithInheritedArea(child, props.state)}
              parentState={props.state}
              isBaseLevel={false}
              index={index}
              canHaveAdders={nvhFormattingEditor.canHaveAdders(props.state.content.areaFullName, child)}/>
      <adder-component if={props.canHaveAdders && !this.nvhFormattingEditor.isPlaceholderDragged(props.state)
                          && nvhFormattingEditor.isChildOfParent(props.state.content.areaFullName)}
              onclick={() => nvhFormattingEditor.addElement(index + 1, props.state, null)}
              onmouseenter={onAdderMouseEnter}
              onmouseleave={onAdderMouseLeave}
              onmouseup={(event) => onAdderMouseUp(event, props.state, index + 1)}
              class={getAdderCssClass(props.state, "other")}
              orientation={props.state.orientation}
              index={index + 1}
              state={props.state}/>
    </template>
  </div>

  <script>
    export default {
      nvhFormattingEditor: null,
      nvhStore: null,      

      onBeforeMount(props) {
        this.nvhFormattingEditor = window.nvhFormattingEditor;
        this.nvhStore = window.nvhStore;
        /* 
        Initialize labelStyles and markupStyles in case any of them is undefined
        this.props.state["markupStyles"].length === 0 is necessary because if someone change entry structure,
        markup styles will not appear in style section
        */
        if (!props.state.markupStyles.length) {
          let markupChildren = this.nvhFormattingEditor.getDirectMarkupChildren(props.state.content.fullName);
          if (markupChildren.length !== 0 ) {
            props.state.markupStyles = this.nvhFormattingEditor.createMarkupStyles(props.state.content.fullName);
          } else {
            props.state.markupStyles = [];
          }
        }
        this.props.state.labelStyles = this.props?.state?.labelStyles || {}
        this.props.state.bulletStyles = this.props?.state?.bulletStyles || {}
      },

      // TODO: unify IFs and FORs
      onMouseUp(event, state) {
        if (this.nvhFormattingEditor.data.canBeDropped) {
          const data = this.nvhFormattingEditor.data.mouseData;
          if (!data) {
            return;
          }
          if (data.type === "choice-item") {
            this.nvhFormattingEditor.data.selectedPlaceholderParentAreaFullName = "";
            if (this.nvhFormattingEditor.isElementWithoutChildrenToWrapper(data, state)) {
              /*Can not drop label to be a wrapper, if it can not have children*/
              this.nvhFormattingEditor.data.canBeDropped = false;
              return;
            }
            if (this.nvhFormattingEditor.isElementToRedundantNestedWrapper(data, this.props.state.content.areaFullName, state)) {
              /*Can not drop label to area with same fullName because it is redundant (redundant child wrapper)*/
              this.nvhFormattingEditor.data.canBeDropped = false;
              return;
            }
            for (let child of state.children) {
              if (!this.nvhFormattingEditor.isParentLabelOfDropObject(data.fullName, child)) {
                /*Can not place label to placeholder, because not all children labels are valid*/
                this.nvhFormattingEditor.data.canBeDropped = false;
                return;
              }
            }
            for (let child of state.children) {
              if (this.nvhFormattingEditor.isPlaceholderAsSameWrapper(data.fullName, child)) {
                /*Can not create redundant parent wrapper*/
                this.nvhFormattingEditor.data.canBeDropped = false;
                return;
              }
            }
            if (!this.nvhFormattingEditor.isChildOfParent(this.props.state.content.areaFullName)) {
              /*
              Dragged element can not be dropped because,
              it is not a child element of the parent placeholder where I want to drop him.
              */
              this.nvhFormattingEditor.data.canBeDropped = false;
              return;
            }

            // TODO: separate method
            state.content.name = data.name;
            state.content.fullName = data.fullName;
            state.content.area = data.name;
            state.content.areaFullName = data.fullName;
            state.content.canHaveChildren = data.children.length !== 0;
            state.styles = {};
            state.labelStyles = {};
            state.bulletStyles = {};

            let markupChildren = this.nvhFormattingEditor.getDirectMarkupChildren(data.fullName);
            if (markupChildren.length !== 0) {
              state.markupStyles = this.nvhFormattingEditor.createMarkupStyles(data.fullName);
            }
          }
          if (data.releaseFunction) {
            data.releaseFunction.run(...data.releaseFunction.parameters);
            data.releaseFunction = null;
          }
          this.nvhFormattingEditor.data.canBeDropped = false;
        }
      },
      onAdderMouseEnter(event) {
        const data = this.nvhFormattingEditor.data.mouseData;
        if (data && data.type === "placeholder") {
          event.currentTarget.classList.add("adder-highligth-dragged");
        }
      },
      onAdderMouseLeave(event) {
        const data = this.nvhFormattingEditor.data.mouseData;
        if (data && data.type === "placeholder") {
          event.currentTarget.classList.remove("adder-highligth-dragged");
        }
      },
      onAdderMouseUp(event, state, index) {
        if (this.nvhFormattingEditor.data.canBeDropped) {
          const data = this.nvhFormattingEditor.data.mouseData;
          if (!data) {
            return;
          }
          if (data.type === "placeholder") {
            state.children.splice(index, 0, data);
            this.nvhFormattingEditor.data.dropInfo.wasSuccessful = true;
            this.nvhFormattingEditor.data.dropInfo.index = index;
            this.nvhFormattingEditor.data.selectedPlaceholderParentAreaFullName = "";
            this.nvhFormattingEditor.data.canBeDropped = false;
          }
          if (data.releaseFunction) {
            data.releaseFunction.run(...data.releaseFunction.parameters);
            data.releaseFunction = null;
          }
          this.nvhFormattingEditor.data.hoveredPlaceholder = null;
          this.nvhFormattingEditor.formattingEditorComponent.update();
        }
      },
      onPlaceholderMouseEnter(event, state) {
        if (!this.nvhFormattingEditor.data.mouseData) {
          event.currentTarget.classList.add("placeholder-mouse-hover");
          this.nvhFormattingEditor.data.hoveredPlaceholder = state;
          this.nvhFormattingEditor.formattingEditorComponent.update();
        }
      },
      onPlaceholderMouseLeave(event, state, parentState) {
        if (!this.nvhFormattingEditor.data.mouseData) {
          event.currentTarget.classList.remove("placeholder-mouse-hover");
          this.nvhFormattingEditor.data.hoveredPlaceholder = null;
          /*
            This is a work-around.
            If I move a placeholder using arrows, sometimes I enter child placeholder
            without entering parent placeholder. I need to assure that after leaving child placeholder,
            the parent will be hovered which is expected behaviour.
          */
          const classList = Array.from(event.currentTarget.parentElement.parentElement.classList);
          if (classList.includes("placeholder")) {
            event.currentTarget.parentElement.parentElement.classList.add("placeholder-mouse-hover");
            this.nvhFormattingEditor.data.hoveredPlaceholder = parentState;
          }
          this.nvhFormattingEditor.formattingEditorComponent.update();
        }
      },
      getBorderColor() {
        return !this.props.state.content.name ? "#c7ced1" : "transparent";
      },
      getBackgroundColor() {
        if (!this.props.state.content.name || this.props.isBaseLevel) {
          return "#ffffff";
        }
        if (this.props.state.children.length === 0) {
          return "transparent";
        }
        return this.nvhFormattingEditor.getColorLightVersion(this.nvhStore.getElementColor(this.props.state.content.fullName));
      },
      // TODO: unify IFs and FORs
      canBeDropped(state) {
        const data = this.nvhFormattingEditor.data.mouseData;
        if (!data || data.type !== "choice-item") {
          return false;
        }

        if (this.nvhFormattingEditor.isElementWithoutChildrenToWrapper(data, state)) {
          /*Can not drop label to be a wrapper, if it can not have children*/
          return false;
        }
        if (this.nvhFormattingEditor.isElementToRedundantNestedWrapper(data, this.props.state.content.areaFullName, state)) {
          /*Can not drop label to area with same fullName because it is redundant (redundant child wrapper)*/
          return false;
        }
        for (let child of state.children) {
          if (!this.nvhFormattingEditor.isParentLabelOfDropObject(data.fullName, child)) {
            /*Can not place label to placeholder, because not all children labels are valid*/
            return false;
          }
        }
        for (let child of state.children) {
          if (this.nvhFormattingEditor.isPlaceholderAsSameWrapper(data.fullName, child)) {
            /*Can not create redundant parent wrapper*/
            return false;
          }
        }
        if (!this.nvhFormattingEditor.isChildOfParent(this.props.state.content.areaFullName)) {
          /*
          Dragged element can not be dropped because,
          it is not a child element of the parent placeholder where I want to drop him.
          */
          return false;
        }
        return true;
      },
      getPlaceholderCssClass(placeholder) {
        let cssClass = "placeholder";
        cssClass += this.nvhFormattingEditor.isPlaceholderActive(placeholder) ? " placeholder-selected" : "";
        cssClass += this.nvhFormattingEditor.isPlaceholderHovered(placeholder) && !this.nvhFormattingEditor.data.mouseData ? " placeholder-mouse-hover" : "";
        cssClass += placeholder.content.name && placeholder.children.length !== 0 ? " placeholder-wrapping-content" : "";
        cssClass += placeholder.children.length === 0 ? " placeholder-no-children" : "";
        cssClass += this.nvhFormattingEditor.isPlaceholderDragged(placeholder) ? " placeholder-dragged" : "";
        cssClass += this.canBeDropped(placeholder) ? " placeholder-can-be-dropped" : "";
        cssClass += this.nvhFormattingEditor.isElementNonExisting(placeholder.content.fullName) ? " placeholder-non-existing" : "";
        return cssClass;
      },
      getPlaceholderInsideWrapperCssClass(placeholder) {
        let cssClass = `placeholder-inside-wrapper placeholder-inside-wrapper-${placeholder.orientation}`;
        cssClass += !placeholder.content.fullName ? " placeholder-inside-wrapper-no-content" : "";
        cssClass += !placeholder.content.fullName && placeholder.children.length !== 0 ? " placeholder-inside-wrapper-group" : "";
        return cssClass;
      },
      getAdderCssClass(placeholder, adderType) {
        let cssClass = "adder"
        cssClass += !this.nvhFormattingEditor.data.mouseData || this.nvhFormattingEditor.data.mouseData.type === "placeholder" ? "" : " adder-invisible";
        if (adderType === "first") {
          cssClass += ` adder-${placeholder.children.length === 0 ? "column": placeholder.orientation}`;
          cssClass += placeholder.children.length === 0 ? " adder-alone" : "";
        } else {
          cssClass += ` adder-${placeholder.orientation}`;
        }
        return cssClass;
      } 
    }
  </script>

  <style>
    .placeholder-inside-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }
    .placeholder-inside-wrapper-column {
      flex-direction: column;
    }
    .placeholder-inside-wrapper-row {
      flex-direction: row;
    }

    .placeholder-wrapping-content {
      border: 4px solid transparent;
    }
    .placeholder-wrapping-content:has(.placeholder:hover) {
      border: 4px solid transparent;
    }

    .placeholder-no-content {
      padding: 10px;
    }

    .placeholder-dragged {
      opacity: 0.8;
    }
    .placeholder-dragged * {
      opacity: 0.8;
    }
    .placeholder-dragged .adder {
      display: none;
    }
    .adder-highligth {
      background-color: var(--color-can-be-dropped);
      padding: 5px !important;
      transition: all 500ms ease;
    }
    .adder-highligth .adder-line * {
      display: none;
    }
    .adder-highligth-dragged {
      background-color: var(--color-is-dragged-over) !important;
    }
    .adder-highligth-dragged .adder-line * {
      display: none;
    }


    .action-panel {
      display: none;
      position: absolute;
      top: -40px;
      left: -4px;
      z-index: 100;
    }
    .placeholder:has(.placeholder-mouse-hover) .action-panel-hovered {
      display: none;
    }
    .placeholder:not(:has(.placeholder-mouse-hover)) .action-panel-hovered {
      display: block;
    }

    .elementholder {
      width: fit-content;
      align-self: flex-start;
    }
    .add-children-component {
      width: 100%;
    }


    .adder-alone {
      padding: 0;
      margin: 15px;
    }
    .adder-invisible {
      visibility: hidden;
    }

    .placeholder-can-be-dropped {
      background-color: var(--color-is-dragged-over-light);
    }
    .placeholder-can-be-dropped > .placeholder-inside-wrapper {
      background-color: var(--color-is-dragged-over-light) !important;
    }
    .placeholder-can-be-dropped:hover {
      background-color:var(--color-yellow-light);
    }
    .placeholder-can-be-dropped:hover > .placeholder-inside-wrapper{
      background-color:var(--color-yellow-light) !important;
    }
    .placeholder-can-be-dropped:hover:has(.placeholder-can-be-dropped:hover) {
      background-color: var(--color-is-dragged-over-light);
    }
    .placeholder-can-be-dropped:hover:has(.placeholder-can-be-dropped:hover) > .placeholder-inside-wrapper {
      background-color: var(--color-is-dragged-over-light) !important;
    }
  </style>
</placeholder-component>