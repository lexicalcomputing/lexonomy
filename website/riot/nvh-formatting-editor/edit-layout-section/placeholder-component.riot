<placeholder-component>
  <action-panel if={!props.isBaseLevel}
                class="action-panel
                      {props.state.status.isHovered ? "action-panel-hovered" : ""}"
                index={props.index}
                parentState={props.parentState}
                state={props.state}/>
  <elementholder-component if={props.state.content.name !== ""}
                          class="elementholder"
                          state={props.state}
                          canHaveAdders={props.canHaveAdders}
                          isBaseLevel={props.isBaseLevel}/>
  <div class="placeholder-inside-wrapper placeholder-inside-wrapper-{props.state.orientation}">
    <adder-component if={props.canHaveAdders && !props.state.status.isDragged
                        && window.nvhFormattingEditor.isChildOfParent(window.nvhFormattingEditor.global.draggedElementFullName, this.props.state.content.areaFullName)}
                    onclick={() => window.nvhFormattingEditor.addElement(0, window.nvhFormattingEditor.formattingEditorComponent, props.state, "row", null)}
                    ondragover={onAdderDragOver}
                    ondragenter={onAdderDragEnter}
                    ondragleave={onAdderDragLeave}
                    ondrop={(event) => onAdderDrop(event, props.state, 0)}
                    class="adder adder-{props.state.children.length === 0 ? "column": props.state.orientation}
                          {props.state.children.length === 0 ? "adder-alone" : ""}"
                    orientation={props.state.children.length === 0 ? "column": props.state.orientation}
                    index={0}
                    state={props.state}/>
    <template each={(child, index) in props.state.children}>
      <placeholder-component onclick={() => window.nvhFormattingEditor.openActionPanel(child)}
                            ondragover={onDragOver}
                            ondrop={(event) => onDrop(event, child)}
                            onmouseenter={(event) => onPlaceholderMouseEnter(event, child, props.state)}
                            onmouseleave={(event) => onPlaceholderMouseLeave(event, child, props.state)}
                            class="placeholder placeholder-{child.orientation}
                                  {child.status.isActive ? "placeholder-selected" : ""}
                                  {child.status.isHovered ? "placeholder-mouse-hover" : ""}
                                  {child.content.name !== "" && child.children.length !== 0 ? "placeholder-wrapping-content" : ""}
                                  {child.children.length === 0 ? "placeholder-no-children" : ""}
                                  {child.status.isDragged ? "placeholder-dragged" : ""}"
                            state={window.nvhFormattingEditor.childWithInheritedArea(child, props.state)}
                            parentState={props.state}
                            isBaseLevel={false}
                            index={index}
                            canHaveAdders={window.nvhFormattingEditor.canHaveAdders(props.state.content.areaFullName, child)}/>
      <adder-component if={props.canHaveAdders && !props.state.status.isDragged
                          && window.nvhFormattingEditor.isChildOfParent(window.nvhFormattingEditor.global.draggedElementFullName, this.props.state.content.areaFullName)}
                      onclick={() => window.nvhFormattingEditor.addElement(index + 1, window.nvhFormattingEditor.formattingEditorComponent, props.state, "row", null)}
                      ondragover={onAdderDragOver}
                      ondragenter={onAdderDragEnter}
                      ondragleave={onAdderDragLeave}
                      ondrop={(event) => onAdderDrop(event, props.state, index + 1)}
                      class="adder adder-{props.state.orientation}"
                      orientation={props.state.orientation}
                      index={index + 1}
                      state={props.state}/>
    </template>
  </div>

  <script>
    export default {
      onDragOver(event) {
        event.preventDefault();
      },
      onDrop(event, state) {
        const rawData = event.dataTransfer.getData("text/plain");
        const data = JSON.parse(rawData);
        if (window.nvhFormattingEditor.global.canBeDropped) {
          if (data.type === "choice-item") {
            window.nvhFormattingEditor.closeActionPanel();
            window.nvhFormattingEditor.global.selectedPlaceholderAreaFullName = "";
            window.nvhFormattingEditor.global.selectedPlaceholderFullName = "";
            if (state.children.length !== 0 && data.children.length === 0) {
              /*Can not drop label to be a wrapper, if it can not have children*/
              window.nvhFormattingEditor.global.canBeDropped = false;
              return;
            }
            if (this.props.state.content.areaFullName.includes(data.fullName) && state.children.length !== 0) {
              /*Can not drop label to area with same fullName because it is redundant*/
              window.nvhFormattingEditor.global.canBeDropped = false;
              return;
            }
            for (let child of state.children) {
              if (!this.isParentLabelOfDropObject(data.fullName, child)) {
                /*Can not place label to placeholder, because not all children labels are valid*/
                window.nvhFormattingEditor.global.canBeDropped = false;
                return;
              }
            }
            if (!window.nvhFormattingEditor.isChildOfParent(data.fullName, this.props.state.content.areaFullName)) {
              /*
              Dragged element can not be dropped because,
              it is not a child element of the parent placeholder where I want to drop him.
              */
              window.nvhFormattingEditor.global.canBeDropped = false;
              return;
            }

            state.content.name = data.name;
            state.content.fullName = data.fullName;
            state.content.area = data.name;
            state.content.areaFullName = data.fullName;
            state.content.color = data.color;
            state.content.canHaveChildren = data.children.length !== 0;
          }
        }
        window.nvhFormattingEditor.global.canBeDropped = false;
      },
      onAdderDragOver(event) {
        event.preventDefault();
      },
      onAdderDragEnter(event) {
        const rawData = event.dataTransfer.getData("text/plain");
        const data = JSON.parse(rawData);
        if (data.type === "placeholder") {
          event.target.classList.add("adder-highligth-dragged");
        }
      },
      onAdderDragLeave(event) {
        const rawData = event.dataTransfer.getData("text/plain");
        const data = JSON.parse(rawData);
        if (data.type === "placeholder") {
          event.target.classList.remove("adder-highligth-dragged");
        }
      },
      onAdderDrop(event, state, index) {
        const rawData = event.dataTransfer.getData("text/plain");
        const data = JSON.parse(rawData);
        if (window.nvhFormattingEditor.global.canBeDropped) {
          if (data.type === "placeholder") {
            window.nvhFormattingEditor.closeActionPanel();
            state.children.splice(index, 0, data);
            state.children[index].status.isHovered = false;
            state.children[index].status.isActive = false;
            window.nvhFormattingEditor.global.dropInfo.wasSuccessful = true;
            window.nvhFormattingEditor.global.dropInfo.index = index;
            window.nvhFormattingEditor.global.selectedPlaceholderAreaFullName = "";
            window.nvhFormattingEditor.global.selectedPlaceholderFullName = "";
            event.target.classList.remove("adder-highligth-dragged");
            window.nvhFormattingEditor.global.canBeDropped = false;
          }
        }
      },

      onPlaceholderMouseEnter(event, state, parentState) {
        event.target.classList.add("placeholder-mouse-hover");
        state.status.isHovered = true;
        /*
          This is a work-around.
          If I create a new placeholder inside of a placeholder,
          the outer one will lose focus. In this way I assign a focus to parent
          placeholder, which is expected behaviour. This is not true for base placeholder.
        */
        const classList = Array.from(event.target.parentElement.parentElement.classList);
        if (classList.includes("placeholder") && !classList.includes("placeholder-first")) {
          event.target.parentElement.parentElement.classList.add("placeholder-mouse-hover");
          parentState.status.isHovered = true;
        }
        window.nvhFormattingEditor.formattingEditorComponent.update();
      },
      onPlaceholderMouseLeave(event, state, parentState) {
        event.target.classList.remove("placeholder-mouse-hover");
        state.status.isHovered = false;

        /*
          This is a work-around.
          If I move a placeholder using arrows, sometimes I enter child placeholder
          without entering parent placeholder. I need to assure that after leaving child placeholder,
          the parent will be hovered which is expected behaviour. This is not true for base placeholder.
        */
        const classList = Array.from(event.target.parentElement.parentElement.classList);
        if (classList.includes("placeholder") && !classList.includes("placeholder-first")) {
          event.target.parentElement.parentElement.classList.add("placeholder-mouse-hover");
          parentState.status.isHovered = true;
        }

        window.nvhFormattingEditor.formattingEditorComponent.update();
      },

      isParentLabelOfDropObject(parentLabel, dropObject) {
        let result = dropObject.content.fullName.includes(parentLabel);
        let alternative = dropObject.content.fullName === "";
        if (!result && !alternative) {
          return false;
        }

        for (let child of dropObject.children) {
          if (!this.isParentLabelOfDropObject(parentLabel, child)) {
            return false;
          }
        }
        return true;
      }
    }
  </script>

  <style>
    .placeholder-inside-wrapper {
      background-color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }
    .placeholder-inside-wrapper-column {
      flex-direction: column;
    }
    .placeholder-inside-wrapper-row {
      flex-direction: row;
    }

    .placeholder-wrapping-content {
      border: 4px dashed rgb(234, 231, 200);
    }
    .placeholder-wrapping-content:has(.placeholder:hover) {
      border: 4px dashed rgb(234, 231, 200);
    }


    .placeholder-dragged {
      opacity: 0.8;
    }
    .placeholder-dragged * {
      opacity: 0.8;
    }
    .placeholder-dragged .adder {
      display: none;
    }
    .adder-highligth {
      background-color: var(--color-can-be-dropped);
      padding: 5px !important;
      transition: all 500ms ease;
    }
    .adder-highligth-dragged {
      background-color: var(--color-is-dragged-over) !important;
      transition: all 200ms ease;
    }


    .action-panel {
      display: none;
      position: absolute;
      top: -40px;
      left: -4px;
      z-index: 100;
    }
    .action-panel:hover {
      opacity: 1 !important;
    }
    .placeholder:has(.placeholder:hover) .action-panel-hovered {
      display: none;
    }
    .placeholder:not(:has(.placeholder:hover)) .action-panel-hovered {
      display: block;
      opacity: 0.3;
    }


    .elementholder {
      width: 100%;
    }


    .adder-alone {
      padding: 0;
      margin: 5px;
    }

    .placeholder-mouse-hover {
      border: 4px solid var(--color-is-hovered);
    }
    .placeholder-mouse-hover:has(.placeholder-mouse-hover) {
      border: 4px solid #f7f6ed;
    }
  </style>
</placeholder-component>