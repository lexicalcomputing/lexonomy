<placeholder-component>
  <action-panel if={window.nvhFormattingEditor.global.mouseData === null}
                class="action-panel
                      {props.state.status.isHovered ? "action-panel-hovered" : ""}"
                index={props.index}
                parentState={props.parentState}
                state={props.state}
                isBaseLevel={props.isBaseLevel}
                isMarkupTypeChild={props.isMarkupTypeChild}/>
  <elementholder-component class="elementholder"
                          state={props.state}
                          canHaveAdders={props.canHaveAdders}
                          isBaseLevel={props.isBaseLevel}/>
  <add-children-component getBackgroundColor={getBackgroundColor}
                          class="add-children-component"
                          state={props.state}
                          canHaveAdders={props.canHaveAdders}>
  </add-children-component>
  <div class="placeholder-inside-wrapper placeholder-inside-wrapper-{props.state.orientation}
              {props.state.content.fullName === "" ? "placeholder-inside-wrapper-no-content" : ""}
              {props.state.content.fullName === "" && props.state.children.length !== 0 ? "placeholder-inside-wrapper-group" : ""}"
      style="background-color: {getBackgroundColor()};
            border: 4px solid {getBorderColor()}">
    <adder-component if={props.canHaveAdders && !props.state.status.isDragged && !markupTypeChildrenLimitReached() && !props.isMarkupTypeChild
                        && window.nvhFormattingEditor.isChildOfParent(window.nvhFormattingEditor.global.draggedElementFullName, this.props.state.content.areaFullName)}
                    onclick={() => window.nvhFormattingEditor.addElement(0, window.nvhFormattingEditor.formattingEditorComponent, props.state, "row", null)}
                    onmouseenter={onAdderMouseEnter}
                    onmouseleave={onAdderMouseLeave}
                    onmouseup={(event) => onAdderMouseUp(event, props.state, 0)}
                    class="adder adder-{props.state.children.length === 0 ? "column": props.state.orientation}
                          {props.state.children.length === 0 ? "adder-alone" : ""}
                          {window.nvhFormattingEditor.global.mouseData === null || window.nvhFormattingEditor.global.mouseData.type === "placeholder" ? "" : "adder-invisible"}"
                    orientation={props.state.children.length === 0 ? "column": props.state.orientation}
                    index={0}
                    state={props.state}/>
    <template each={(child, index) in props.state.children}>
      <placeholder-component onclick={() => window.nvhFormattingEditor.selectPlaceholder(child, props.state)}
                            title={window.nvhFormattingEditor.isElementNonExisting(child.content.fullName) ? "Entry structure changed, and element with path '" + child.content.fullName + "'' does not exist anymore. Remove it to fix the formatting structure." : ""}
                            onmouseup={(event) => onMouseUp(event, child)}
                            onmouseenter={(event) => onPlaceholderMouseEnter(event, child, props.state)}
                            onmouseleave={(event) => onPlaceholderMouseLeave(event, child, props.state)}
                            class="placeholder placeholder-{child.orientation}
                                  {child.status.isActive ? "placeholder-selected" : ""}
                                  {child.status.isHovered && window.nvhFormattingEditor.global.mouseData === null ? "placeholder-mouse-hover" : ""}
                                  {child.content.name !== "" && child.children.length !== 0 ? "placeholder-wrapping-content" : ""}
                                  {child.children.length === 0 ? "placeholder-no-children" : ""}
                                  {child.status.isDragged ? "placeholder-dragged" : ""}
                                  {!isContainerConfiguredCorrectly(child) ? "placeholder-configured-incorrectly" : ""}
                                  {canBeDropped(child) ? "placeholder-can-be-dropped" : ""}
                                  {window.nvhFormattingEditor.isElementNonExisting(child.content.fullName) ? "placeholder-non-existing" : ""}"
                            state={window.nvhFormattingEditor.childWithInheritedArea(child, props.state)}
                            parentState={props.state}
                            isBaseLevel={false}
                            index={index}
                            canHaveAdders={window.nvhFormattingEditor.canHaveAdders(props.state.content.areaFullName, child)}
                            isMarkupType={window.nvhFormattingEditor.isMarkupType(child.content.fullName)}
                            isMarkupTypeChild={props.isMarkupType}/>
      <adder-component if={props.canHaveAdders && !props.state.status.isDragged && !markupTypeChildrenLimitReached() && !props.isMarkupTypeChild
                          && window.nvhFormattingEditor.isChildOfParent(window.nvhFormattingEditor.global.draggedElementFullName, this.props.state.content.areaFullName)}
                      onclick={() => window.nvhFormattingEditor.addElement(index + 1, window.nvhFormattingEditor.formattingEditorComponent, props.state, "row", null)}
                      onmouseenter={onAdderMouseEnter}
                      onmouseleave={onAdderMouseLeave}
                      onmouseup={(event) => onAdderMouseUp(event, props.state, index + 1)}
                      class="adder adder-{props.state.orientation}
                            {window.nvhFormattingEditor.global.mouseData === null || window.nvhFormattingEditor.global.mouseData.type === "placeholder" ? "" : "adder-invisible"}"
                      orientation={props.state.orientation}
                      index={index + 1}
                      state={props.state}/>
    </template>
  </div>

  <script>
    export default {
      onBeforeMount() {
        /* Initialize labelStyles and markupStyles in case any of them is undefined */
        if (this.props.state["markupStyles"] === undefined) {
          let markupChildren = window.nvhFormattingEditor.hasDirectMarkupChild(this.props.state.content.fullName);
          if (markupChildren.length !== 0 ) {
            this.props.state["markupStyles"] = window.nvhFormattingEditor.createMarkupStyles(this.props.state.content.fullName);
          } else {
            this.props.state["markupStyles"] = [];
          }
        }
        if (this.props.state["labelStyles"] === undefined) {
          this.props.state["labelStyles"] = {};
        }
        if (this.props.state["bulletStyles"] === undefined) {
          this.props.state["bulletStyles"] = {};
        }
      },

      onMouseUp(event, state) {
        if (window.nvhFormattingEditor.global.canBeDropped) {
          const data = window.nvhFormattingEditor.global.mouseData;
          if (data === null) {
            return;
          }
          if (data.type === "choice-item") {
            // Remove following line during selected placeholder refactor
            //window.nvhFormattingEditor.global.selectedPlaceholder = null;
            window.nvhFormattingEditor.global.selectedPlaceholderParentAreaFullName = "";
            if (window.nvhFormattingEditor.isElementWithoutChildrenToWrapper(data, state)) {
              /*Can not drop label to be a wrapper, if it can not have children*/
              window.nvhFormattingEditor.global.canBeDropped = false;
              return;
            }
            if (window.nvhFormattingEditor.isElementToRedundantNestedWrapper(data, this.props.state.content.fullName, state)) {
              /*Can not drop label to area with same fullName because it is redundant (redundant child wrapper)*/
              window.nvhFormattingEditor.global.canBeDropped = false;
              return;
            }
            for (let child of state.children) {
              if (!window.nvhFormattingEditor.isParentLabelOfDropObject(data.fullName, child)) {
                /*Can not place label to placeholder, because not all children labels are valid*/
                window.nvhFormattingEditor.global.canBeDropped = false;
                return;
              }
            }
            for (let child of state.children) {
              if (window.nvhFormattingEditor.isPlaceholderAsSameWrapper(data.fullName, child)) {
                /*Can not create redundant parent wrapper*/
                window.nvhFormattingEditor.global.canBeDropped = false;
                return;
              }
            }
            if (!window.nvhFormattingEditor.isChildOfParent(data.fullName, this.props.state.content.areaFullName)) {
              /*
              Dragged element can not be dropped because,
              it is not a child element of the parent placeholder where I want to drop him.
              */
              window.nvhFormattingEditor.global.canBeDropped = false;
              return;
            }

            state.content.name = data.name;
            state.content.fullName = data.fullName;
            state.content.area = data.name;
            state.content.areaFullName = data.fullName;
            state.content.canHaveChildren = data.children.length !== 0;
            state.styles = {};
            state.labelStyles = {};
            state.bulletStyles = {};

            let markupChildren = window.nvhFormattingEditor.hasDirectMarkupChild(data.fullName);
            if (markupChildren.length !== 0) {
              state["markupStyles"] = window.nvhFormattingEditor.createMarkupStyles(data.fullName);
            }
          }
          if (data.releaseFunction !== undefined && data.releaseFunction !== null) {
            data.releaseFunction.run(...data.releaseFunction.parameters);
            data.releaseFunction = null;
          }
          window.nvhFormattingEditor.global.canBeDropped = false;
        }
      },
      onAdderMouseEnter(event) {
        const data = window.nvhFormattingEditor.global.mouseData;
        if (data !== null && data.type === "placeholder") {
          event.currentTarget.classList.add("adder-highligth-dragged");
        }
      },
      onAdderMouseLeave(event) {
        const data = window.nvhFormattingEditor.global.mouseData;
        if (data !== null && data.type === "placeholder") {
          event.currentTarget.classList.remove("adder-highligth-dragged");
        }
      },
      onAdderMouseUp(event, state, index) {
        if (window.nvhFormattingEditor.global.canBeDropped) {
          const data = window.nvhFormattingEditor.global.mouseData;
          if (data === null) {
            return;
          }
          if (data.type === "placeholder") {
            state.children.splice(index, 0, data);
            window.nvhFormattingEditor.global.dropInfo.wasSuccessful = true;
            window.nvhFormattingEditor.global.dropInfo.index = index;
            window.nvhFormattingEditor.global.selectedPlaceholderParentAreaFullName = "";
            window.nvhFormattingEditor.global.canBeDropped = false;
          }
          if (data.releaseFunction !== undefined && data.releaseFunction !== null) {
            data.releaseFunction.run(...data.releaseFunction.parameters);
            data.releaseFunction = null;
          }
          //window.nvhFormattingEditor.global.mouseData = null; // KEY FIX, not necessary because done in global mouse up
          window.nvhFormattingEditor.formattingEditorComponent.update();
        }
      },
      markupTypeChildrenLimitReached() {
        return this.props.isMarkupType && this.props.state.children.length === 2;
      },
      getPlaceholderTitle(state) {
        if (!window.nvhFormattingEditor.isMarkupType(state.content.fullName)) {
          return "";
        }
        if (state.children.length == 0) {
          return "";
        }
        if (state.children.length !== 2) {
          return "Container with element of markup type (red frame),\nshould have exactly two subcontainers.";
        }
        if (state.children[0].content.fullName === "" || state.children[1].content.fullName === "") {
          return "Container with element of markup type (red frame)\nshould not have empty subcontainers.";
        }
        if (state.children[0].content.fullName === state.children[1].content.fullName) {
          return "Container with element of markup type (red frame),\nshould not have two subcontainers with the same element name.";
        }
        if (this.areMarkupTypeChildrenSwapped(state)) {
          return "Subcontainers of a container with element of a markup type (red frame),\n should be swapped.";
        }
        return "";
      },
      isContainerConfiguredCorrectly(state) {
        if (!window.nvhFormattingEditor.isMarkupType(state.content.fullName)) {
          return true;
        }
        if (state.children.length == 0) {
          return true;
        }
        if (state.children.length !== 2) {
          return false;
        }
        if (state.children[0].content.fullName === "" || state.children[1].content.fullName === "") {
          return false;
        }
        if (state.children[0].content.fullName === state.children[1].content.fullName) {
          return false;
        }
        if (this.areMarkupTypeChildrenSwapped(state)) {
          return false;
        }
        return true;
      },
      areMarkupTypeChildrenSwapped(state) {
        let firstType = window.nvhFormattingEditor.isMarkupType(state.children[0].content.fullName);
        let secondType = window.nvhFormattingEditor.isMarkupTypeChild(state.children[1].content.fullName);
        return firstType && secondType;
      },
      onPlaceholderMouseEnter(event, state, parentState) {
        if (window.nvhFormattingEditor.global.mouseData === null) {
          event.currentTarget.classList.add("placeholder-mouse-hover");
          state.status.isHovered = true;
          /*
            This is a work-around.
            If I create a new placeholder inside of a placeholder,
            the outer one will lose focus. In this way I assign a focus to parent
            placeholder, which is expected behaviour. This is not true for base placeholder.
          */
          const classList = Array.from(event.currentTarget.parentElement.parentElement.classList);
          if (classList.includes("placeholder") && !classList.includes("placeholder-first")) {
            event.currentTarget.parentElement.parentElement.classList.add("placeholder-mouse-hover");
            parentState.status.isHovered = true;
          }
          window.nvhFormattingEditor.formattingEditorComponent.update();
        }
      },
      onPlaceholderMouseLeave(event, state, parentState) {
        if (window.nvhFormattingEditor.global.mouseData === null) {
          event.currentTarget.classList.remove("placeholder-mouse-hover");
          state.status.isHovered = false;
          /*
            This is a work-around.
            If I move a placeholder using arrows, sometimes I enter child placeholder
            without entering parent placeholder. I need to assure that after leaving child placeholder,
            the parent will be hovered which is expected behaviour. This is not true for base placeholder.
          */
          const classList = Array.from(event.currentTarget.parentElement.parentElement.classList);
          if (classList.includes("placeholder") && !classList.includes("placeholder-first")) {
            event.currentTarget.parentElement.parentElement.classList.add("placeholder-mouse-hover");
            parentState.status.isHovered = true;
          }
          window.nvhFormattingEditor.formattingEditorComponent.update();
        }
      },
      getBorderColor() {
        if (this.props.state.content.name === "" && this.props.state.children.length !== 0) {
          return "#c7ced1";
        }
        return "transparent";
      },
      getBackgroundColor() {
        if (this.props.state.content.name === "" || this.props.isBaseLevel) {
          return "#ffffff";
        }
        if (this.props.state.children.length === 0) {
          return "transparent";
        }
        return window.nvhFormattingEditor.getColorLightVersion(window.nvhStore.getElementColor(this.props.state.content.fullName));
      },
      canBeDropped(state) {
        const data = window.nvhFormattingEditor.global.mouseData;
        if (data === null || data.type !== "choice-item") {
          return false;
        }

        if (window.nvhFormattingEditor.isElementWithoutChildrenToWrapper(data, state)) {
          /*Can not drop label to be a wrapper, if it can not have children*/
          return false;
        }
        if (window.nvhFormattingEditor.isElementToRedundantNestedWrapper(data, this.props.state.content.fullName, state)) {
          /*Can not drop label to area with same fullName because it is redundant (redundant child wrapper)*/
          return false;
        }
        for (let child of state.children) {
          if (!window.nvhFormattingEditor.isParentLabelOfDropObject(data.fullName, child)) {
            /*Can not place label to placeholder, because not all children labels are valid*/
            return false;
          }
        }
        for (let child of state.children) {
          if (window.nvhFormattingEditor.isPlaceholderAsSameWrapper(data.fullName, child)) {
            /*Can not create redundant parent wrapper*/
            return false;
          }
        }
        if (!window.nvhFormattingEditor.isChildOfParent(data.fullName, this.props.state.content.areaFullName)) {
          /*
          Dragged element can not be dropped because,
          it is not a child element of the parent placeholder where I want to drop him.
          */
          return false;
        }
        return true;
      }
    }
  </script>

  <style>
    .placeholder-inside-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }
    .placeholder-inside-wrapper-column {
      flex-direction: column;
    }
    .placeholder-inside-wrapper-row {
      flex-direction: row;
    }

    .placeholder-wrapping-content {
      border: 4px solid transparent;
    }
    .placeholder-wrapping-content:has(.placeholder:hover) {
      border: 4px solid transparent;
    }

    .placeholder-no-content {
      padding: 10px;
    }

    .placeholder-dragged {
      opacity: 0.8;
    }
    .placeholder-dragged * {
      opacity: 0.8;
    }
    .placeholder-dragged .adder {
      display: none;
    }
    .adder-highligth {
      background-color: var(--color-can-be-dropped);
      padding: 5px !important;
      transition: all 500ms ease;
    }
    .adder-highligth .adder-line * {
      display: none;
    }
    .adder-highligth-dragged {
      background-color: var(--color-is-dragged-over) !important;
    }
    .adder-highligth-dragged .adder-line * {
      display: none;
    }


    .action-panel {
      display: none;
      position: absolute;
      top: -40px;
      left: -4px;
      z-index: 100;
    }
    .placeholder:has(.placeholder-mouse-hover) .action-panel-hovered {
      display: none;
    }
    .placeholder:not(:has(.placeholder-mouse-hover)) .action-panel-hovered {
      display: block;
    }

    .placeholder-configured-incorrectly {
      outline: 4px solid var(--color-red-normal) !important;
    }


    .elementholder {
      width: fit-content;
      align-self: flex-start;
    }
    .add-children-component {
      width: 100%;
    }


    .adder-alone {
      padding: 0;
      margin: 15px;
    }
    .adder-invisible {
      visibility: hidden;
    }

    .placeholder-can-be-dropped {
      background-color: var(--color-is-dragged-over-light);
    }
    .placeholder-can-be-dropped > .placeholder-inside-wrapper {
      background-color: var(--color-is-dragged-over-light) !important;
    }
    .placeholder-can-be-dropped:hover {
      background-color:var(--color-yellow-light);
    }
    .placeholder-can-be-dropped:hover > .placeholder-inside-wrapper{
      background-color:var(--color-yellow-light) !important;
    }
    .placeholder-can-be-dropped:hover:has(.placeholder-can-be-dropped:hover) {
      background-color: var(--color-is-dragged-over-light);
    }
    .placeholder-can-be-dropped:hover:has(.placeholder-can-be-dropped:hover) > .placeholder-inside-wrapper {
      background-color: var(--color-is-dragged-over-light) !important;
    }
  </style>
</placeholder-component>