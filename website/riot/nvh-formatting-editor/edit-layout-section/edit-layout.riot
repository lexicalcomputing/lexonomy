<edit-layout>
  <div class="edit-layout-container">
    <div class="scrollable-div">
      <template each={(child, index) in props.schema.children}>
        <placeholder-component onclick={() => deleteElement(index, global.parent, props.schema, props.editing, global, true)}
                              ondragover={onDragOver}
                              ondrop={(event) => onDrop(event, child)}
                              ondragleave={onDragLeave}
                              class="placeholder placeholder-{child.orientation}"
                              state={childWithInheritedArea(child, null)}
                              editing={props.editing}
                              global={global}
                              isBaseLevel={true}
                              delete-element={deleteElement}
                              add-element={addElement}
                              child-with-inherited-area={childWithInheritedArea}/>
      </template>
    </div>
  </div>

  <script>
    export default {
      global: null,

      onBeforeMount(props) {
        this.global = {
          canBeRemovedIfHovered: true, /*remove only the deepest hovered "placeholder", the other ones should stay as they are*/
          canBeDropped: true, /*drop element only to deepest hovered "placeholder"*/
          parent: props.parent,
        };
      },
      onBeforeUpdate(props) {
        this.global = {
          canBeRemovedIfHovered: true,
          canBeDropped: true,
          parent: props.parent,
        };
        this.removeDeletedElements(this.props.schema);
      },

      onDragOver(event) {
        event.preventDefault();
      },
      onDrop(event, state) {
        const rawData = event.dataTransfer.getData("text/plain");
        const data = JSON.parse(rawData);
        if (this.global.canBeDropped) {
          state.content.name = data.name;
          state.content.area = data.name;
          state.content.color = data.color;
        }
        this.global.parent.update();
      },

      addElement(index, component, state, editingMode) {
        let newElement = {
          isDeleted: false,
          orientation: editingMode,
          content: {
            name: "",
            area: "",
            color: ""
          },
          children: []
        };
        state.children.splice(index, 0, newElement);
        component.update();
      },
      deleteElement(index, component, state, editing, global, isBaseLevel) {
        if (!editing.enabled || editing.mode !== "delete") {
          return;
        }
        if (global.canBeRemovedIfHovered && !isBaseLevel) {
          state.children[index].isDeleted = true;
        }
        global.canBeRemovedIfHovered = false;
        if (isBaseLevel) {
          component.update();
        }
      },
      removeDeletedElements(state) {
        if (state === null) {
          return null;
        }
        Array.from(state.children).map(child => this.removeDeletedElements(child));
        state.children = Array.from(state.children).filter(child => !child.isDeleted);
      },
      childWithInheritedArea(child, state) {
        if (state === null) {
          return child;
        }
        child.content.area = child.content.name === "" ? state.content.area : child.content.name;
        return child;
      },
    }
  </script>

  <style>
    .edit-layout-container {
      border: 1px black dashed;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      width: fit-content;
      height: 100%;
      overflow: auto;
      min-width: 100%;
    }


    .placeholder {
      position: relative;
      border: 4px solid #f7f6ed;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-grow: 1;
      min-width: fit-content;
      width: calc(100% - 20px);
      margin: 10px;
    }
    /*
    ensure that all "placeholder" children will have same height
    */
    .placeholder > .placeholder-inside-wrapper > .placeholder {
      height: calc(100% - 20px);
    }
    /*
    both "placeholder-row" and "placeholder-column" have same flex-direction,
    only "placeholder-inside-wrapper" will have corresponding
    flex-direction based on its orientation
    */
    .placeholder-row {
      flex-direction: column;
      border: 4px solid var(--color-row);
      padding: 20px;
    }
    .placeholder-column {
      flex-direction: column;
      border: 4px solid var(--color-column);
      padding: 20px;
    }


    .adder:hover {
      background-color:rgb(236, 244, 244);
      border: 1px black dashed;
      cursor: pointer;
    }
    .adder-first {
      height: calc(100% - 20px);
      min-height: 60px;
    }
    /*
    "adder-column" is present in columns,
    and rows with no children, because it is easier to click
    */
    .adder-column {
      padding: 5px;
      width: calc(100% - 20px);
      margin: 0 10px;
      min-width: 100px;
    }
    .adder-column:hover {
      padding: 20px 0px;
    }
    /*
    "adder-row" is present in rows
    */
    .adder-row {
      height: calc(100% - 20px);
      padding: 5px;
      margin: 10px 0;
    }
    .adder-row:hover {
      padding: 0px 20px;
    }
    .adder:hover .plus-icon-wrapper {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: 100%;
    }
  </style>
</edit-layout>