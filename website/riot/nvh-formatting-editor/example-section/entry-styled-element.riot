<entry-styled-element class="entry-styled-element {nvhFormattingEditor.data.hoveredLayoutContainer == props.schema ? 'layout-container-mouse-hover' : ''}"
      attr-path={props.schema.content.path}
      onclick={!props.readOnly && onClick}
      onmouseover={!props.readOnly && onMouseOver}
      onmouseleave={!props.readOnly && onMouseLeave}>
   <div class="element-holder element-holder-{props.schema.orientation}"
         style="{state.cssRules.element}">
      <div class="entry-styled-element-value-wrapper">
         <pre if={state.bulletValue}
               style={state.cssRules.bullet}>
            {state.bulletValue}
         </pre>
         <pre if={hasLabelBeforeValue()}
               class="entry-styled-element-label-before"
               style={state.cssRules.label}>
            {state.labelStyles["label-text-value"]}
         </pre>
         <raw-html if={!props.schema.content.path && state.elementStyles["text-value"]}
               content={state.elementStyles["text-value"]}/>
         <div if={state.isShowingElementValue}
               class="element-holder-content-wrapper">
            <div if={props.element.value}
                  class="element-holder-content-block">
               <div is="{state.valueComponentName}"
                     value={state.value}
                     raw-value={props.element.value}
                     schema={props.schema}>
                  <!--pre if={hasLabelBeforeValue() && !props.schema.children.length}
                        slot="left-label"
                        class="example-item-label-before"
                        style={state.cssRules.label}>
                     {state.labelStyles["label-text-value"]}
                  </pre>
                  <pre if={hasLabelAfterValue() && !props.schema.children.length}
                        slot="right-label"
                        class="example-item-label-after"
                        style={state.cssRules.label}>
                     {state.labelStyles["label-text-value"]}
                  </pre-->
               </div>
            </div>
         </div>
      </div>
      <div each={childSchema in props.schema.children}
            class="element-holder-list element-holder-list-{props.schema.orientation}">
         <entry-styled-element if={!childSchema.content.name}
               schema={childSchema}
               element={props.element}
               read-only={props.readOnly}/>
         <entry-styled-element each={childElement in getSchemaChildElements(childSchema)}
               schema={childSchema}
               element={childElement}
               read-only={props.readOnly}/>
      </div>
      <pre if={hasLabelAfterValue()}
            class="entry-styled-element-label-before"
            style={state.cssRules.label}>
         {state.labelStyles["label-text-value"]}
      </pre>
   </div>

   <script>
      export default {
         bindings: [["nvhFormattingEditor", "selectedLayoutContainerChange", "onSelectedLayoutContainerChange"],
                    ["nvhFormattingEditor", "hoveredLayoutContainerChange", "onHoveredLayoutContainerChange"],
                    ["nvhFormattingEditor", "updateSchemas", "onUpdateSchemas"]],

         state: {
            elementType: null,
            value: null,
            bulletValue: null
         },

         onBeforeMount(props) {
            this.nvhFormattingEditor = window.nvhFormattingEditor
            this.nvhStore = window.nvhStore
            this.refreshState(props)
         },

         onBeforeUpdate(props) {
            this.refreshState(props)
         },

         onSelectedLayoutContainerChange(){
            let addClass = !this.props.readOnly && (this.nvhFormattingEditor.data.selectedLayoutContainer == this.props.schema)
            this.root.querySelector("& > .element-holder").classList.toggle("element-holder-active", addClass)
         },

         onHoveredLayoutContainerChange(){
            let addClass = !this.props.readOnly && (this.nvhFormattingEditor.data.hoveredLayoutContainer == this.props.schema)
            this.root.querySelector("& > .element-holder").classList.toggle("element-holder-hovered", addClass)
         },

         onUpdateSchemas(schemas){
            schemas.includes(this.props.schema) && this.update()
         },

         onClick(evt) {
            if(evt.target.closest("entry-styled-element") == this.root){
               this.nvhFormattingEditor.selectLayoutContainer(this.props.schema)
               evt.stopPropagation()
               window.scrollIntoViewVerticallyIfNeeded(document.querySelector(".layout-container.layout-container-selected"))
            }
         },

         onMouseOver(evt) {
            if(evt.target.closest("entry-styled-element") == this.root){
               this.nvhFormattingEditor.setHoveredLayoutContainer(this.props.schema)
            }
         },

         onMouseLeave(event, state, parentState) {
            if (!this.nvhFormattingEditor.data.draggedLayoutContainer) {
               this.nvhFormattingEditor.setHoveredLayoutContainer(null)
            }
         },

         refreshState(props) {
            this.state.elementType = this.nvhStore.getElementConfig(this.props.schema.content.path)?.type
            let type = ["int", "string", "list", "empty"].includes(this.state.elementType) ? "basic" : this.state.elementType
            this.state.valueComponentName = `entry-styled-element-${type}`
            this.state.elementStyles = this.nvhFormattingEditor.getStyles(this.props.schema, "element")
            this.state.labelStyles = this.nvhFormattingEditor.getStyles(this.props.schema, "label")
            this.state.bulletStyles = this.nvhFormattingEditor.getStyles(this.props.schema, "bullet")
            this.state.cssRules = {
               element: this.nvhFormattingEditor.getCssRules(props.schema, "element"),
               label: this.nvhFormattingEditor.getCssRules(props.schema, "label"),
               bullet: this.nvhFormattingEditor.getCssRules(props.schema, "bullet")
            }
            this.state.directMarkupChildren = window.nvhFormattingEditor.getDirectMarkupChildren(this.props.schema.content.path)

            this.refreshBulletValue()
            this.refreshValue()
            // not a container or group
            this.state.isShowingElementValue = !this.props.schema.children.length && this.props.schema.content.name
         },

         refreshValue() {
            if (this.state.elementType === "empty") {
               this.state.value = this.state.elementStyles["text-value"]
            } else {
               let value = this.state.elementStyles["allow-html"] ? this.props.element.value : window.escapeHTML(this.props.element.value)
               if(this.state.directMarkupChildren.length){
                  let createReplaceString = (childPath, find, child) => {
                     let style = this.nvhFormattingEditor.getCssRules(this.props.schema, "markup", childPath)
                     let markupStyles = window.nvhFormattingEditor.getStyles(this.props.schema, "markup", child.path)
                     let markupUrl = ""
                     if(this.props.readOnly && markupStyles.applyURL){
                        markupUrl = window.nvhFormattingEditor.getElementMarkupUrl(child)
                     }
                     let markupHtml = markupUrl
                           ? `<a href="${markupUrl}" target="_blank" class="entry-styled-element-markup-link" style="${style}">${find}</a>`
                           : `<span style="${style}">${find}</span>`

                     return this.getPunc(markupStyles, "left")
                           + markupHtml
                           + this.getPunc(markupStyles, "right")
                  }
                  value = window.nvhStore.replaceMarkupOccurrences(value, this.props.element, createReplaceString)
               }
               this.state.value = this.getPunc(this.state.elementStyles, "left")
                     + value
                     + this.getPunc(this.state.elementStyles, "right")
            }
         },

         refreshBulletValue() {
            this.state.bulletValue = ""
            if(this.hasBullet()){
               let bullet = ""
               if (this.state.bulletStyles["show-bullets"]) {
                  bullet = this.state.bulletStyles["show-bullets"] == "custom" ? this.state.bulletStyles["custom-bullet"] : this.getBullet()
               }
               if(bullet){
                  this.state.bulletValue = this.getPunc(this.state.bulletStyles, "left")
                        + bullet
                        + this.getPunc(this.state.bulletStyles, "right")
               }
            }
         },

         getSchemaChildElements(schema){
            return window.nvhStore.findElements(el => el.path == schema.content.path, this.props.element)
         },

         getPunc(styles, side) {
            return styles?.[`${side}Punc`] || ""
         },

         getBullet(){
            if(!this.props.element.parent){
               return null
            }
            let idx = this.props.element.parent.children.filter(child => child.path == this.props.element.path)
                  .indexOf(this.props.element)
            idx = idx != -1 ? idx + 1 : null
            if(idx){
               return {
                  number: num => num,
                  letter: window.numToAlphabet,
                  letterCap: num => window.numToAlphabet(num).toUpperCase(),
                  roman:  num => window.numToRomanNum(num).toLowerCase(),
                  romanCap: window.numToRomanNum
               }[this.state.bulletStyles["show-bullets"]]?.(idx)
            }
            return null
         },

         hasLabelBeforeValue() {
            return this.state.labelStyles["label-text-value"]
               && (this.state.labelStyles["show-label-before"])
         },

         hasLabelAfterValue() {
            return this.state.labelStyles["label-text-value"]
               && (!this.state.labelStyles["show-label-before"])
         },

         hasSiblings(){
            return this.props.element.parent && this.props.element.parent.children.filter(child => child.path == this.props.element.path).length > 1
         },

         hasBullet() {
            return this.state.bulletStyles["show-bullets"]
               && (this.state.bulletStyles["bullet-use-with-single-item"] || this.hasSiblings())
         }
      }
   </script>

   <style type="scss">
      pre {
         margin: 0;
         text-wrap: wrap;
         font-family: inherit;
      }
      .link-no-decoration {
         text-decoration: none;
      }
      .element-holder {
         display: flex;
         flex-wrap: wrap;
         width: fit-content;
         align-items: baseline;
         margin: 2px 0;
      }
      .entry-styled-element-value-wrapper{
         display: flex; // so bullets are on the same line
         align-items: baseline;
      }
      .element-holder-has-bullet {
         flex-wrap: nowrap;
      }
      .element-holder-list {
         display: flex;
         flex-wrap: wrap;
         width: fit-content;
         align-items: baseline;
      }
      .element-holder-list-column {
         flex-direction: column;
      }
      .element-holder-list-row {
         flex-direction: row;
      }
      .element-holder-content-block {
         display: flex;
         align-items: baseline;
      }
      .element-holder-column {
         flex-direction: column;
      }
      .element-holder-hovered {
         outline: 2px solid rgba(255, 20, 0, 0.4);// !important;
         outline-offset: 3px;
         border-radius: 5px;
      }
      .element-holder-hovered:has(.element-holder-hovered) {
         outline: none;
      }
      .element-holder-active {
         //box-shadow: 0 0 0px 3px white, 0 0 11px 7px #dbbc0dc7;
         //border: 1px solid rgba(222, 84, 72, 0.7);
         outline: 3px solid #F44336;
         outline-offset: 1px;
         border-radius: 5px;
         //animation: pulse 1.7s infinite;
      }
      .entry-styled-element-label-vertical {
         width: fit-content;
         text-wrap: nowrap;
      }
      .entry-styled-element-markup-link{
         text-decoration: unset;
         &:hover{
            color: unset
         }
      }
      .entry-styled-element-label-before {
         margin-right: 5px !important;
         width: fit-content;
         text-wrap: nowrap;
      }
      .entry-styled-element-label-after {
         margin-left: 5px !important;
         width: fit-content;
         text-wrap: nowrap;
      }
      raw-html{
         margin: 2px;
      }

      @keyframes pulse {
           0% {
             box-shadow: 0 0 0px 3px white,0 0 0 0 rgba(222, 84, 72, 1);
          }
          90% {
             box-shadow: 0 0 0px 3px white,0 0 0 16px rgba(222, 84, 72, 0);
          }
          100% {
             box-shadow: 0 0 0px 3px white,0 0 0 0 rgba(222, 84, 72, 0);
          }
      }
   </style>
</entry-styled-element>
