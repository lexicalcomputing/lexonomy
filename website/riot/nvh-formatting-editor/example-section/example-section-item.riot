<example-section-item>
  <div class="element-holder element-holder-{props.schema.orientation}
              {isEmptyPlaceholder() ? "element-holder-empty-placeholder" : "element-holder-used-placeholder"}
              {props.schema.status.isActive && (hasChildWithContent(props.schema) || isDisplayLabel()) ? "element-holder-active" : ""}
              {props.schema.status.isHovered && (hasChildWithContent(props.schema) || isDisplayLabel()) ? "element-holder-hovered" : ""}
              {props.schema.status.isHovered && !hasChildWithContent(props.schema) && !isDisplayLabel() ? "element-holder-hovered-empty" : ""}">
    <div if={props.schema.children.length === 0}
        class="element-holder-content-wrapper">
      <div class="element-holder-content-block">
        <div if={props.schema.content.fullName === props.entry.path && props.entry.value !== ""}
            class="element-holder-content"
            style={props.schema.content.fullName !== "" ? getCssStyles() : ""}>
          {formatValue(props.schema.content.fullName)}
        </div>
      </div>
    </div>
    <div each={childSchema in props.schema.children}
        class="element-holder element-holder-{childSchema.orientation}">
      <example-section-item if={childSchema.content.name === "" /*empty placeholder*/}
                            schema={childSchema}
                            entry={props.entry}/>
      <example-section-item if={props.schema.content.area === childSchema.content.area
                                && childSchema.content.name !== "" /*render parent label*/}
                            schema={childSchema}
                            entry={props.entry}/>
      <template if={props.schema.content.area !== childSchema.content.area
                    && childSchema.content.name !== ""}
                each={childEntry in window.nvhFormattingEditor.getEntryChildren(props.entry, [])}>
        <example-section-item if={childSchema.content.fullName === childEntry.path}
                              schema={childSchema}
                              entry={childEntry}/>
      <div if={!props.entry.children.map(e => e.path).includes(childSchema.content.fullName) && childSchema.status.isHovered /*entry does not contain element but schema does*/}
          class="element-holder-hovered-empty-entry" style="display: none"></div>
      </template>
    </div>
  </div>

  <script>
    export default {
      hasChildWithContent(state) {
        for (let child of state.children) {
          if (child.content.name !== "" && child.children.length === 0) {
            return true;
          }
          if (this.hasChildWithContent(child)) {
            return true;
          }
        }
        return false;
      },
      isDisplayLabel() {
        return this.props.schema.children.length === 0 && this.props.schema.content.name !== "";
      },
      isEmptyPlaceholder() {
        return this.props.schema.content.name === "";
      },
      formatValue(fullName) {
        var result = this.getPunc(this.props.schema.content.fullName, "leftPunc");

        if (window.nvhStore.getElementConfig(fullName).type === "int") {
          result += this.formatInt(this.props.schema.content.fullName);
        } else {
          result += this.props.entry.value
        }

        result += this.getPunc(this.props.schema.content.fullName, "rightPunc");
        return result;
      },
      /*TODO: refactor*/
      formatInt(fullName) {
        if (fullName === "") {
          return "";
        }

        let thousandsDivider = this.props.schema.styles === undefined || this.props.schema.styles.thousandsDivider === undefined ? " " : this.props.schema.styles.thousandsDivider;
        let decimalPlaceDivider = this.props.schema.styles === undefined || this.props.schema.styles.decimalPlaceDivider === undefined ? "." : this.props.schema.styles.decimalPlaceDivider;

        var numberSplitted = this.props.entry.value.split('.');
        var numberNonDecimalReversed = numberSplitted[0].split('').reverse().join('');
        var numberDecimal = numberSplitted[1];

        var result = "";
        for (let i = 0; i < numberNonDecimalReversed.length; i++) {
          if (i !== 0 && i % 3 === 0) {
            result += thousandsDivider;
          }
          result += numberNonDecimalReversed[i]
        }

        result = result.split('').reverse().join('');
        if (numberDecimal !== undefined) {
          result += decimalPlaceDivider + numberDecimal;
        }
        
        return result;
      },
      getCssStyles() {
        let styles = this.props.schema.styles;
        if (styles === undefined) {
          return;
        }
        let result_css = "";
        for (let i = 0; i < Object.keys(styles).length; i++) {
          let option = Object.keys(styles)[i];
          let value = styles[option];
          if (value === null || value === undefined) {
            continue;
          }
          if (option === "thousandsDivider" || option === "decimalPlaceDivider" || option === "leftPunc" || option === "rightPunc") {
            continue;
          }
          if (option === "border-radius" || option === "padding" || option === "margin") {
            value = value + "px";
          } else if (option === "box-shadow") {
            value = value + "px " + value + "px " + value + "px " + "grey";
          }
          result_css += option + ":" + value + ";";
        }
        return result_css;
      },
      getPunc(fullName, option) {
        if (fullName === "") {
          return "";
        }
        let styles = this.props.schema.styles;
        if (styles === undefined) {
          return "";
        }
        let punc = this.props.schema.styles[option];
        if (punc === undefined) {
          return "";
        }
        switch (punc) {
          case "roundBrackets":
            return option === "leftPunc" ? "(" : ")";
          case "squareBrackets":
            return option === "leftPunc" ? "[" : "]";
          case "curlyBrackets":
            return option === "leftPunc" ? "{" : "}";
          case "colon":
            return option === "leftPunc" ? ":" : ":";
          case "comma":
            return option === "leftPunc" ? "," : ",";
          case "dot":
            return option === "leftPunc" ? "." : ".";
          case "semicolon":
            return option === "leftPunc" ? ";" : ";";
          default:
            return ""
        }
      },
    }
  </script>

  <style>
    .element-holder-used-placeholder {
      margin: 3px;
    }
    .element-holder-empty-placeholder {
      margin: 0;
    }
    .element-holder {
      display: flex;
      flex-wrap: wrap;
      width: fit-content;
      align-items: baseline;
      line-height: 1;
    }
    .element-holder-content-block {
      display: flex;
    }
    .element-holder-column {
      flex-direction: column;
    }
    .element-holder-hovered {
      outline: 2px solid var(--color-is-hovered);
    }
    .element-holder-hovered:has(.element-holder-hovered) {
      outline: none;
    }
    .element-holder-hovered:has(.element-holder-hovered-empty) {
      outline: none;
    }
    .element-holder-hovered:has( > .element-holder > .element-holder-hovered-empty-entry) {
      outline: none;
    }
    .element-holder-active {
      outline: 2px solid var(--color-is-active) !important;
    }
  </style>
</example-section-item>