<example-section-item>
  <div class="element-holder element-holder-{props.schema.orientation}
              {isEmptyPlaceholder() ? "element-holder-empty-placeholder" : "element-holder-used-placeholder"}
              {window.nvhFormattingEditor.isMarkupTypeChild(props.schema.content.fullName) ? "element-holder-markup-type-child" : ""}
              {window.nvhFormattingEditor.isMarkupType(props.schema.content.fullName) ? "element-holder-markup-type" : ""}
              {window.nvhFormattingEditor.isMarkupType(props.schema.content.fullName) && props.schema.status.isHovered ? "element-holder-markup-type-hovered" : ""}
              {window.nvhFormattingEditor.isMarkupType(props.schema.content.fullName) && props.schema.status.isActive ? "element-holder-markup-type-active" : ""}
              {props.schema.status.isActive && (hasChildWithContent(props.schema) || isDisplayLabel()) ? "element-holder-active" : ""}
              {props.schema.status.isHovered && (hasChildWithContent(props.schema) || isDisplayLabel()) ? "element-holder-hovered" : ""}
              {props.schema.status.isHovered && !hasChildWithContent(props.schema) && !isDisplayLabel() ? "element-holder-hovered-empty" : ""}"
        style={props.schema.children.length !== 0 ? getCssStyles(this.props.schema.styles) : ""}>
    <div if={props.schema.children.length === 0}
        class="element-holder-content-wrapper">
      <div class="element-holder-content-block">
        <div if={props.schema.content.fullName === props.entry.path && (props.entry.value !== "" && (this.state.type === "int" || this.state.type === "string" || this.state.type === "list") || this.state.type === "empty") && state.valueStylePairs === null}
            class="element-holder-content"
            style={props.schema.content.fullName !== "" ? getCssStyles(this.props.schema.styles) : ""}>
          {this.state.value}
        </div>
        <!-- TODO: Currently markup supports only text and in type, in future implement for all types-->
        <div if={props.schema.content.fullName === props.entry.path && (props.entry.value !== "" && (this.state.type === "int" || this.state.type === "string" || this.state.type === "list") || this.state.type === "empty") && state.valueStylePairs !== null}
            style="display: flex;">
          <pre each={child in this.state.valueStylePairs}
              style={getCssStyles(child.styles)}>
            {child.value}
          </pre>
        </div>
        <example-url-item if={props.schema.content.fullName === props.entry.path && props.entry.value !== "" && this.state.type === "url"}
          value={this.state.value}
          styles={this.props.schema.styles}
          get-css-styles={getCssStyles}
        />
        <example-bool-item if={props.schema.content.fullName === props.entry.path && props.entry.value !== "" && this.state.type === "bool"}
          value={this.state.value}
          styles={this.props.schema.styles}
          get-css-styles={getCssStyles}
        />
        <example-image-item if={props.schema.content.fullName === props.entry.path && props.entry.value !== "" && this.state.type === "image"}
          value={this.state.value}
          styles={this.props.schema.styles}
          get-css-styles={getCssStyles}
        />
        <example-audio-item if={props.schema.content.fullName === props.entry.path && props.entry.value !== "" && this.state.type === "audio"}
          value={this.state.value}
          styles={this.props.schema.styles}
          get-css-styles={getCssStyles}
        />
        <example-video-item if={props.schema.content.fullName === props.entry.path && props.entry.value !== "" && this.state.type === "video"}
          value={this.state.value}
          styles={this.props.schema.styles}
          get-css-styles={getCssStyles}
        />
        <pre if={props.schema.content.fullName === props.entry.path && props.entry.value !== "" && this.state.type === "markup" && this.state.value.prefix !== ""}
            class="element-holder-content"
            style={props.schema.content.fullName !== "" ? getCssStyles(this.props.schema.styles) : ""}>
          {this.state.value.prefix}
        </pre>
        <div if={props.schema.content.fullName === props.entry.path && props.entry.value !== "" && this.state.type === "markup" && this.state.value.markup !== ""}
            class="element-holder-content
                  {props.schema.markupStatus.isHovered ? "element-holder-hovered" : ""}
                  {props.schema.markupStatus.isActive ? "element-holder-active" : ""}"
            style={props.schema.content.fullName !== "" ? getCssStyles(this.props.schema.markupStyles) : ""}>
          {this.state.value.markup}
        </div>
        <pre if={props.schema.content.fullName === props.entry.path && props.entry.value !== "" && this.state.type === "markup" && this.state.value.suffix !== ""}
            class="element-holder-content"
            style={props.schema.content.fullName !== "" ? getCssStyles(this.props.schema.styles) : ""}>
          {this.state.value.suffix}
        </pre>
      </div>
    </div>
    <div each={childSchema in props.schema.children}
        class="element-holder element-holder-{childSchema.orientation}">
      <example-section-item if={childSchema.content.name === "" /*empty placeholder*/}
                            onclick={() => onExampleItemClick(childSchema, props.schema)}
                            onmouseenter={(event) => onExampleItemMouseEnter(event, childSchema)}
                            onmouseleave={(event) => onExampleItemMouseLeave(event, childSchema)}
                            class="{props.isFormatting ? "example-section-item" : ""}"
                            schema={childSchema}
                            entry={props.entry}
                            isFormatting={props.isFormatting}/>
      <example-section-item if={props.schema.content.area === childSchema.content.area
                                && childSchema.content.name !== "" /*render parent label*/}
                            onclick={() => onExampleItemClick(childSchema, props.schema)}
                            onmouseenter={(event) => onExampleItemMouseEnter(event, childSchema)}
                            onmouseleave={(event) => onExampleItemMouseLeave(event, childSchema)}
                            class="{props.isFormatting ? "example-section-item" : ""}"
                            schema={childSchema}
                            entry={props.entry}
                            isFormatting={props.isFormatting}/>
      <template if={props.schema.content.area !== childSchema.content.area
                    && childSchema.content.name !== ""}
                each={childEntry in window.nvhFormattingEditor.getEntryChildren(props.entry, [])}>
        <example-section-item if={childSchema.content.fullName === childEntry.path}
                              onclick={() => onExampleItemClick(childSchema, props.schema)}
                              onmouseenter={(event) => onExampleItemMouseEnter(event, childSchema)}
                              onmouseleave={(event) => onExampleItemMouseLeave(event, childSchema)}
                              class="{props.isFormatting ? "example-section-item" : ""}"
                              schema={childSchema}
                              entry={childEntry}
                              isFormatting={props.isFormatting}/>
        <div if={!props.entry.children.map(e => e.path).includes(childSchema.content.fullName) && childSchema.status.isHovered /*entry does not contain element but schema does*/}
            class="element-holder-hovered-empty-entry" style="display: none"></div>
      </template>
    </div>
  </div>

  <script>
    export default {
      state: {
        type: null,
        value: null,
        valueStylePairs: null,
      },

      onBeforeMount() {
        let fullName = this.props.schema.content.fullName;
        if (fullName === "") {
          return;
        }
        if (window.nvhStore.getElementConfig(fullName).type === "markup" && this.props.schema.children.length === 2) {
          this.connectMarkupElementWithChildren(this.props.schema);
        }
        this.formatValue(fullName);
      },
      onBeforeUpdate() {
        let fullName = this.props.schema.content.fullName;
        if (fullName === "") {
          return;
        }
        if (window.nvhStore.getElementConfig(fullName).type === "markup" && this.props.schema.children.length === 2) {
          this.connectMarkupElementWithChildren(this.props.schema);
        }
        this.formatValue(fullName);
      },

      onExampleItemMouseEnter(event, state) {
        if (!this.props.isFormatting) {
          return;
        }
        if (window.nvhFormattingEditor.global.mouseData === null) {
          event.currentTarget.classList.add("placeholder-mouse-hover");
          state.status.isHovered = true;
          window.nvhFormattingEditor.formattingEditorComponent.update();
        }
      },
      onExampleItemMouseLeave(event, state) {
        if (!this.props.isFormatting) {
          return;
        }
        if (window.nvhFormattingEditor.global.mouseData === null) {
          event.currentTarget.classList.remove("placeholder-mouse-hover");
          state.status.isHovered = false;
          window.nvhFormattingEditor.formattingEditorComponent.update();
        }
      },
      onExampleItemClick(state, parentState) {
        if (this.props.isFormatting) {
          window.nvhFormattingEditor.selectPlaceholder(state, parentState)
        }
      },

      hasChildWithContent(state) {
        for (let child of state.children) {
          if (child.content.name !== "" && child.children.length === 0) {
            return true;
          }
          if (this.hasChildWithContent(child)) {
            return true;
          }
        }
        return false;
      },
      isDisplayLabel() {
        return this.props.schema.children.length === 0 && this.props.schema.content.name !== "";
      },
      isEmptyPlaceholder() {
        return this.props.schema.content.name === "";
      },
      connectMarkupElementWithChildren(schema) {
        /* Markup type will always have two children:
          first one will be markup element child
          second one will be the markup element itself
        */
        let displayMarkupPlaceholder = this.props.schema.children[1];
        let styleMarkupPlaceholder = this.props.schema.children[0];
        let markupValue = { value: null };
        displayMarkupPlaceholder["markupStyles"] = styleMarkupPlaceholder.styles;
        displayMarkupPlaceholder["markupStatus"] = styleMarkupPlaceholder.status;
        displayMarkupPlaceholder["markupValue"] = markupValue;
        styleMarkupPlaceholder["markupValue"] = markupValue;
      },
      formatValue(fullName) {
        this.state.type = window.nvhStore.getElementConfig(fullName).type;
        let leftPunc = this.getPunc("leftPunc", this.props.schema.styles);
        let rightPunc = this.getPunc("rightPunc", this.props.schema.styles);

        let markupValueStylesPair = null;
        let valueStylesPair = null;
        let markupChildren = window.nvhFormattingEditor.hasDirectMarkupChild(fullName);
        if (markupChildren.length !== 0) { /*means that has markup children*/
          markupValueStylesPair = this.getMarkupValueStylePair();
          valueStylesPair = this.getValueStylePair(this.props.entry.value, markupValueStylesPair, this.props.schema.styles);
          this.state.valueStylePairs = valueStylesPair;
        } else if (this.state.type === "empty") {
          this.state.value = this.props.schema.styles["text-value"];
        } else {
          let value = this.props.entry.value;
          this.state.value = leftPunc + value + rightPunc;
        }
      },
      createValueObject(prefix, markup, suffix) {
        return {
          prefix: prefix,
          markup: markup,
          suffix: suffix,
        };
      },
      getValueStylePair(value, markupValueStylePair, styles) {
        let leftPunc = this.getPunc("leftPunc", styles);
        let rightPunc = this.getPunc("rightPunc", styles);

        let result = [];
        for (let child of markupValueStylePair) {
          let splittedValue = value.split(child.value);
          if (splittedValue[0] !== "") {
            let normalObject = {
              value: result.length === 0 ? leftPunc + splittedValue[0] : splittedValue[0], /*prepend left punc only before first normalObject*/
              styles: styles,
            };
            result.push(normalObject);
          }
          if (child.value !== "") {
            let leftMarkupPunc = this.getPunc("leftPunc", child.styles);
            let rightMarkupPunc = this.getPunc("rightPunc", child.styles);
            let markupObject = {
              value: leftMarkupPunc + child.value + rightMarkupPunc,
              styles: child.styles,
            };
            result.push(markupObject);
          }
          value = splittedValue.slice(1).join(child.value);
        }
        if (value !== "") {
          let normalObject = {
            value: value + rightPunc,
            styles: styles,
          };
          result.push(normalObject);
        }
        return result;
      },
      getMarkupValueStylePair() {
        let result = [];
        let object;
        for (let child of this.props.entry.children) {
          if (window.nvhFormattingEditor.isMarkupType(child.path)) {
            object = {
              value: child.value,
              styles: this.getStyleToFullName(child.path),
            };
            result.push(object);
          }
        }
        return result;
      },
      getStyleToFullName(fullName) {
        if (!Array.isArray(this.props.schema.markupStyles)) {
          console.log("this.props.schema.markupStyles is not iterable, this.props.schema.markupStyles = '", this.props.schema.markupStyles, "'.");
          return {};
        }
        for (let child of this.props.schema.markupStyles) {
          if (child.fullName === fullName) {
            return child.styles;
          }
        }
      },
      formatMarkup(value, schema, leftPunc, rightPunc) {
        let leftMarkupPunc = this.getPunc("leftPunc", schema.markupStyles);
        let rightMarkupPunc = this.getPunc("rightPunc", schema.markupStyles);

        if (schema.markupValue === undefined) {
          return this.createValueObject(leftPunc + value + rightPunc, "", "");
        }

        let markupValue = schema.markupValue.value;
        let values = value.split(markupValue);
        let prefix = values[0];

        if (markupValue === "") {
          return this.createValueObject(leftPunc + value + rightPunc, "", "");
        } else if (values.length > 1) {
          let suffix = values.slice(1).join(markupValue);
          return this.createValueObject(leftPunc + prefix, leftMarkupPunc + markupValue + rightMarkupPunc, suffix + rightPunc);
        } else { /*markupChildValue is not present in markupValue*/
          return this.createValueObject(leftPunc + prefix + rightPunc, "", "");
        }
      },
      getCssStyles(styles) {
        if (styles === undefined) {
          return;
        }
        let result_css = "";
        for (let i = 0; i < Object.keys(styles).length; i++) {
          let option = Object.keys(styles)[i];
          let value = styles[option];
          if (value === null || value === undefined) {
            continue;
          }
          if (option === "thousandsDivider" || option === "decimalPlaceDivider" || option === "leftPunc" || option === "rightPunc" || option === "border-color" || option === "border-width") {
            continue;
          }
          if (option === "border-radius" || option === "padding" || option === "margin" || option === "max-width" || option === "max-height" || option === "font-size") {
            value = value + "px";
          } else if (option === "box-shadow") {
            value = value + "px " + value + "px " + value + "px " + "grey";
          } else if (option === "text-decoration") {
            let array = styles["text-decoration"];
            if (array === undefined) {
              continue;
            }
            let values = "";
            for (let feature of array) {
              values = values + " " + feature;
            }
            value = values;
          } else if (option === "border") {
            let borderColor = styles["border-color"] === undefined ? "black" : styles["border-color"];
            let borderWidth = styles["border-width"] === undefined ? "1px" : styles["border-width"] + "px";
            value = borderWidth + " " + value + " " + borderColor;
          }
          result_css += option + ":" + value + ";";
        }
        return result_css;
      },
      getPunc(option, styles) {
        if (styles === undefined) {
          return "";
        }
        let punc = styles[option];
        if (punc === undefined) {
          return "";
        }
        switch (punc) {
          case "roundBrackets":
            return option === "leftPunc" ? "(" : ")";
          case "squareBrackets":
            return option === "leftPunc" ? "[" : "]";
          case "curlyBrackets":
            return option === "leftPunc" ? "{" : "}";
          case "colon":
            return option === "leftPunc" ? ":" : ":";
          case "comma":
            return option === "leftPunc" ? "," : ",";
          case "dot":
            return option === "leftPunc" ? "." : ".";
          case "semicolon":
            return option === "leftPunc" ? ";" : ";";
          default:
            return ""
        }
      },
    }
  </script>

  <style>
    pre {
      margin: 0;
      font-family: "Roboto Condensed", sans-serif;
    }
    .example-section-item {
      cursor: pointer;
    }
    .element-holder-used-placeholder {
      margin: 3px;
    }
    .element-holder-empty-placeholder {
      margin: 0;
    }
    .element-holder {
      display: flex;
      flex-wrap: wrap;
      width: fit-content;
      align-items: baseline;
      line-height: 1;
    }
    .element-holder-content-block {
      display: flex;
      align-items: baseline;
      line-height: 1;
    }
    .element-holder-column {
      flex-direction: column;
    }
    .element-holder-markup-type-child {
      display: none;
    }
    .element-holder-markup-type:has(.element-holder-markup-type-child) {
      outline: none;
    }
    .element-holder-markup-type-hovered:has(.element-holder-markup-type) {
      outline: 2px solid var(--color-is-hovered);
    }
    .element-holder-markup-type-active:has(.element-holder-markup-type) {
      outline: 2px solid var(--color-is-active);
    }
    .element-holder-hovered {
      outline: 2px solid var(--color-is-hovered);
    }
    .element-holder-hovered:has(.element-holder-hovered) {
      outline: none;
    }
    .element-holder-hovered:has(.element-holder-hovered-empty) {
      outline: none;
    }
    .element-holder-hovered:has( > .element-holder > .element-holder-hovered-empty-entry) {
      outline: none;
    }
    .element-holder-active {
      outline: 2px solid var(--color-is-active) !important;
    }
    .element-holder-content-hovered {
      outline: 2px solid var(--color-is-hovered);
    }
    .element-holder-content-active {
      outline: 2px solid var(--color-is-active) !important;
    }
  </style>
</example-section-item>