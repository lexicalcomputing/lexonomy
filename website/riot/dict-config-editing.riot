<dict-config-editing>
   <loading-overlay if={state.isLoading || state.isSaving}/>
   <h1>Custom entry editor</h1>
   <p>
      The built-in entry editor can be replaced by a custom one by defining javascript functions.
   </p>
   <label class="checkbox">
      <input type="checkbox"
            checked={state.data._useOwnEditor}
            onclick={onCheckboxClick}/>
      <span>Use own editor</span>
   </label>
   <br><br>
   <div id="editors"
         class="row"
         style="display: none;">
      <div class="input-field mb-16">
         <label>JavaScript</label>
         <pre id="editor_js"
               class="codeEditor language-javascript"
               oninput={onJSInput}></pre>
         <div id="codeStatus"></div>
         <span class="helper-text">
            You can customize the editor by defining two functions in JavaScript: one that will render the HTML editor from the XML entry and one that will harvest the (edited) HTML back into XML. If you would like to see an example,
            <a class="pointer" onclick={ exampleJS }>click here to load a sample JavaScript code</a>.
         </span>
      </div>
      <div class="input-field">
         <label for="editor_css">CSS</label>
         <pre id="editor_css"
               oninput={onCSSInput}
               class="codeEditor language-css"></pre>
         <span class="helper-text">
            You can customize the editor look and feel by writing your own CSS styles. If you would like to see an example,
            <a class="pointer" onclick={ exampleCSS }>click here to load a sample CSS style</a>.
         </span>
      </div>
   </div>
   <dict-config-buttons save-data={saveData}></dict-config-buttons>

   <script>
      export default {
         state: {
            isLoading: true,
            isSaving: false,
            data: {
               _useOwnEditor: undefined,
               _js: "",
               _css: ""
            }
         },

         onCheckboxClick(evt){
            this.state.data._useOwnEditor = evt.target.checked
            $("#editors").toggle(evt.target.checked)
         },

         exampleJS() {
            this.state.data._js =
`{
   editor: function(div, entry, uneditable){
      //div = the div into which you should render the editor
      //entry.id = the entry ID (a number, eg. 123), or zero if new entry
      //entry.content = the entry's XML source code, eg. "<entry></headword>hello</headword></entry>"
      //uneditable = true if we want the entry to be uneditable (read-only)
      $(div).html("<div class='myEditor'>HEADWORD: <input class='headword' "+(uneditable?"disabled":"")+"/></div>");
      $(div).find("input.headword").val($($.parseXML(entry.content)).find("headword").html());
   },
   harvester: function(div){
      //div = the div from which you should harvest the contents of the editor
      var headword=$(div).find("input.headword").val();
      return "<entry><headword>"+headword+"</headword></entry>";
   },
   adjustDocSpec: function (docSpec) {
      // NOTE: you normally want to use this method if you don't have a custom editor,
      // but just want to change certain aspects of how Xonomy presents the document.
      $.each(docSpec.elements, function (elementName, elementSpec) {
         // Expand <sense> elements by default.
         if (elementName === 'sense') {
            elementSpec.collapsed = function (jsElement) { return false; }
         }
         // Make <example> read-only
         if (elementName === 'example') {
            elementSpec.isReadOnly = true;
         }
         // Hide <partOfSpeech>.
         if (elementName === 'partOfSpeech') {
            elementSpec.isInvisible = true;
         }
      });
   }
}`
            this.codeEditorJS.updateCode(this.state.data._js)
            this.checkJSCode()
         },

         exampleCSS() {
            this.state.data._css =
`div.myEditor {padding: 20px; font-size: 1.25em}
div.myEditor input {font-weight: bold}`
            this.codeEditorCSS.updateCode(this.state.data._css)
         },

         onMounted() {
            let options = {
              tab: '   ',
              indentOn: /[{(\[]$/
            }
            this.codeEditorJS = CodeJar($('#editor_js')[0], Prism.highlightElement.bind(this, $('#editor_js')[0], false, null), options)
            this.codeEditorCSS = CodeJar($('#editor_css')[0], Prism.highlightElement.bind(this, $('#editor_css')[0], false, null), options)
            this.codeEditorJS.onUpdate(this.onJSCodeUpdate.bind(this))
            this.codeEditorCSS.onUpdate(this.onCSSCodeUpdate.bind(this))

            this.store.loadDictionaryConfig("editing")
                  .done(response => {
                     this.state.data = response.content
                  })
                  .always(response => {
                     this.update({isLoading: false})
                     if(this.state.data._useOwnEditor || (typeof this.state.data._useOwnEditor == "undefined" && this.state.data._js)){
                        this.codeEditorJS.updateCode(this.state.data._js)
                        this.codeEditorCSS.updateCode(this.state.data._css)
                        $("#editors").show()
                     }
                     response.content._js && this.checkJSCode()
                  })
         },

         onJSCodeUpdate(){
            this.state.data._js = this.codeEditorJS.toString()
            this.checkJSCode()
         },

         onCSSCodeUpdate(){
            this.state.data._css = this.codeEditorCSS.toString()
         },

         getConfigData() {
            return Object.assign({
               _version: window.LEXONOMY_VERSION
            }, this.state.data)
         },

         checkJSCode(){
            if(this.state.data._js){
               let isOk = false
               let err = ""
               try{
                  new Function("return " + this.state.data._js)()
                  isOk = true
               } catch(e){
                  err = e.toString().split('\n')[0]
               }
               $("#codeStatus").html(isOk ? `<b class="green-text">valid</b>` : `<b class="red-text">${err}</b>`)
            }
         },

         saveData() {
            this.update({isSaving: true})
            this.store.updateDictionaryConfig("editing", this.getConfigData())
                  .always(() => this.update({isSaving: false}))
         }
      }
   </script>

   <style>
      textarea{
         min-height: 30vh;
      }
      #editor_js{
         padding-top: 25px;
      }
      #codeStatus{
         bottom: 0px;
         position: sticky;
         right: 1px;
         left: 1px;
         background-color: #dfdfdf;
         padding: 3px 8px;
         margin-bottom: 5px;
      }
      .codeEditor{
         margin: 0;
         min-height: 150px;
      }
   </style>
</dict-config-editing>
