<dict-config-editing>
   <loading-overlay if={state.isLoading || state.isSaving}/>
   <h1>Custom entry editor</h1>
   <p>
      The built-in entry editor can be replaced by a custom one by defining javascript functions.
   </p>
   <label class="checkbox">
      <input type="checkbox"
            checked={state.data.useOwnEditor}
            onclick={onCheckboxClick}/>
      <span>Use own editor</span>
   </label>
   <br><br>
   <div id="editors"
         class="row displayFlex mb-16"
         style="display: none;">
      <div class="jsCode input-field">
         <label>JavaScript</label>
         <pre id="editor_js"
               class="codeEditor language-javascript"
               onkeydown={onKeyDown}></pre>
         <div id="codeStatus"
               class="displayFlex">
            <span class="codeStatusMessage"></span>
            <small class="ml-auto grey-text">Ctrl+s or âŒ˜+s to save</small>
         </div>
         <span class="helper-text">
            You can create your own entry editor (<a class="pointer" onclick={onShowEditorHelpClick}>learn more</a>). If you would like to see an example,
            <a class="pointer" onclick={ exampleJS }>click here to load a sample JavaScript code</a>.
         </span>
      </div>
      <div class="cssCode input-field">
         <label for="editor_css">CSS</label>
         <pre id="editor_css"
               onkeydown={onKeyDown}
               class="codeEditor language-css"></pre>
         <span class="helper-text mt-2">
            You can customize the editor look and feel by writing your own CSS styles. If you would like to see an example,
            <a class="pointer" onclick={ exampleCSS }>click here to load a sample CSS style</a>.
         </span>
      </div>
   </div>
   <dict-config-buttons save-data={saveData}></dict-config-buttons>

   <script>
      export default {
         state: {
            isLoading: true,
            isSaving: false,
            isJSValid: null,
            data: {
               useOwnEditor: undefined,
               js: "",
               css: ""
            }
         },

         onCheckboxClick(evt){
            this.state.data.useOwnEditor = evt.target.checked
            $("#editors").toggle(evt.target.checked)
            this.checkJSCode()
         },

         exampleJS() {
            this.state.data.js =
`{
   editor: function(options) {
      // options = {
      //   node: the node into which you should render the editor
      //   entry = JSON object representing the entry
      //   readOnly = true if we want the entry to be uneditable
      //   onChange = method to call if data changes
      //   onValidChange - method to call if data state changes from valid to invalid or vice versa
      // }
      this.options = options
      this.node = $(options.node)
      this.entry = options.entry
      let editorNode = $("<div class='myEditor'><h3>My custom editor</h3></div>").appendTo(this.node)
      this.contentNode = $('<div class="myEditorContentNode"></div>').appendTo(editorNode)
      this.isValid = null
      this._render()
      this._validate()
   },

   getValue: function() {
      return {
         name: "entry",
         value: this.contentNode.find("input.headword").val(),
         children: [{
            name: "partOfSpeech",
            value: this.contentNode.find("input.partOfSpeech").val()
         }]
      }
   },

   update: function(entry) {
      this.entry = entry
      this._render()
      this._validate()
   },

   _render: function() {
      this.contentNode.empty()
      $(\`<label>headword</label>\`).appendTo(this.contentNode)
      $(\`<input class="headword"
            \$\{this.options.readOnly? "disabled" : ""}
            value="\$\{this.entry.value}"/>\`)
            .appendTo(this.contentNode)
            .on("input", this._onInput.bind(this))
            .on("change", this.options.onChange)
      $(\`<label>Part of speech</label>\`).appendTo(this.contentNode)
      $(\`<input class="partOfSpeech"
            \$\{this.options.readOnly? "disabled" : ""}
            value="\$\{window.nvhStore.findElement(e => e.name == "partOfSpeech").value}"/>\`)
            .appendTo(this.contentNode)
            .on("input", this._onInput.bind(this))
            .on("change", this.options.onChange)
   },

   _onInput: function() {
      this._validate()
   },

   _validate: function() {
      let wasValid = this.isValid
      this.isValid = this.contentNode.find("input.headword").val() !== ""
            && this.contentNode.find("input.partOfSpeech").val() !== ""
      if (wasValid != this.isValid) {
         this.options.onValidChange(this.isValid)
      }
   }
}`
            this.codeEditorJS.updateCode(this.state.data.js)
            this.checkJSCode()
         },

         exampleCSS() {
            this.state.data.css =
`.myEditor{
   padding: 0 30px
}
.myEditor headword{
   font-size: 1.25em
}`
            this.codeEditorCSS.updateCode(this.state.data.css)
         },

         onMounted() {
            let options = {
              tab: '   ',
              indentOn: /[{(\[]$/
            }
            this.codeEditorJS = CodeJar($('#editor_js')[0], Prism.highlightElement.bind(this, $('#editor_js')[0], false, null), options)
            this.codeEditorCSS = CodeJar($('#editor_css')[0], Prism.highlightElement.bind(this, $('#editor_css')[0], false, null), options)
            this.codeEditorJS.onUpdate(this.onJSCodeUpdate.bind(this))
            this.codeEditorCSS.onUpdate(this.onCSSCodeUpdate.bind(this))

            this.store.loadDictionaryConfig("editing")
                  .done(response => {
                     this.state.data = response.content
                  })
                  .always(response => {
                     this.update({isLoading: false})
                     this.state.data.js && this.codeEditorJS.updateCode(this.state.data.js)
                     this.state.data.css && this.codeEditorCSS.updateCode(this.state.data.css)
                     if(this.state.data.useOwnEditor){
                        $("#editors").show()
                     }
                     this.state.data.js && this.checkJSCode()
                  })
         },

         onJSCodeUpdate(){
            this.state.data.js = this.codeEditorJS.toString()
            this.checkJSCode()
         },

         onCSSCodeUpdate(){
            this.state.data.css = this.codeEditorCSS.toString()
         },

         onKeyDown(evt){
            if(evt.keyCode == 83 && (evt.ctrlKey || evt.metaKey)){
               evt.preventDefault()
               if(this.state.isJSValid){
                  this.saveData()
               } else {
                  M.toast({html: "Invalid code"})
               }
            }
         },

         onShowEditorHelpClick(){
            window.modal.open({
               title: "Custom editor",
               tag: "raw-html",
               props: {
                  content: `Your custom editor should be JavaScript object with these functions:<br>
                  <b class="monospace">editor(options)</b><br>
                  <div class="pl-4">
                     Options is object with following keys:<br>
                     <div class="pl-4">
                        node: jQuery object of the root node to which editor should be attached.<br>
                        entry: JSON representation of the entry<br>
                        readOnly: true/false <br>
                        onChange: method to be called every time the entry changes<br>
                        onValidChange: method to be called every time the entry valid status changes (entry is in valid or invalid state)<br><br>
                     </div>
                  </div>
                  <b class="monospace">update(entry)</b><br>
                  <div class="pl-4">
                     Redraw the editor after data change (e.g. user navigates to another entry, uses undo/redo commands...).<br><br>
                  </div>
                  <b class="monospace">getValue()</b>
                  <div class="pl-4">
                     Returns JSON representation of the actual state of the entry.<br>
      <pre>
      {
         name: "entry",
         value: "",
         children: [{
            name: "headword",
            value: ""
         }]
      }</pre>
                  </div>`
               }
            })
         },

         getConfigData() {
            return Object.assign({
               _version: window.LEXONOMY_VERSION
            }, this.state.data)
         },

         checkJSCode(){
            let isValid = false
            if(this.state.data.js){
               let err = ""
               try{
                  let editorFn = new Function("return " + this.state.data.js)()
                  ;["editor", "getValue", "update"].forEach(fnName => {
                     if(typeof editorFn[fnName] != "function"){
                        throw `Missing ${fnName}() function.`
                     }
                  })
                  isValid = true
               } catch(e){
                  err = e.toString().split('\n')[0]
               }
               $("#codeStatus .codeStatusMessage").html(isValid ? `<b class="green-text">valid</b>` : `<b class="red-text">${err}</b>`)
               this.state.isJSValid = isValid
            }
            $("#submit_button").toggleClass("disabled", !isValid)
         },

         saveData() {
            this.update({isSaving: true})
            this.store.updateDictionaryConfig("editing", this.getConfigData())
                  .always(() => this.update({isSaving: false}))
         }
      }
   </script>

   <style>
      textarea{
         min-height: 30vh;
      }
      #editors{
         gap: 20px;

      }
      .jsCode{
         max-width: 65%;
      }
      .cssCode{
         max-width: 35%;
      }
      @media screen and (max-width: 1450px) {
         #editors{
            flex-wrap: wrap;
         }
         .jsCode,
         .cssCode{
            max-width: 100%;
         }
      }
      #editor_js{
         padding-top: 25px;
      }
      #codeStatus{
         position: sticky;
         bottom: 0px;
         right: 1px;
         left: 1px;
         background-color: #dfdfdf;
         padding: 3px 8px;
         margin-bottom: 5px;
         align-items: center;
      }
      .codeEditor{
         margin: 0;
         min-height: 150px;
      }
   </style>
</dict-config-editing>
