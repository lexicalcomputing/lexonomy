<dict-config-editing>
   <loading-overlay if={state.isLoading || state.isLoadingEditor || state.isSaving}/>
   <h1 class="pageTitle">Custom entry editor</h1>
   <dict-configuration-issues config-id="editing"/>
   <p>
      The built-in entry editor can be replaced by a custom one by defining javascript functions.
   </p>
   <div class="switch">
      <label>
         <input id="custom_css"
            type="checkbox"
            checked={state.data.useOwnEditor}
            onchange={onUseOwnEditorClick} >
         <span class="lever"></span>
         Use own editor
      </label>
   </div>
   <br><br>

   <div if={!state.isLoadingEditor}
         id="editors"
         style="display: none;">
      <div class="grey-text">
         You can create your own entry editor (<a class="pointer" onclick={onShowEditorHelpClick}>learn more</a>). If you would like to see an example,
         <a class="pointer" onclick={onLoadExampleClick}>click here to load a sample code</a>.
      </div>
      <h2 id="title_js"
            class="mt-8">JavaScript</h2>
      <div id="editorJS"
            onkeydown={onKeyDown}></div>
      <div id="codeStatus"
            class="displayFlex">
         <span class="codeStatusMessage"></span>
         <small class="ml-auto grey-text">Ctrl+s or âŒ˜+s to save</small>
      </div>

      <h2 id="title_css"
            class="mt-8">CSS</h2>
      <div id="editorCSS"
            onkeydown={onKeyDown}></div>
      <div class="fixed-action-btn buttons mr-16">
         <a class="btn-floating btn-large grey"
               onclick={onScrollToClick.bind(this, "js")}>
            <span class="white-text">JS</span>
         </a>
         <a class="btn-floating btn-large grey"
               onclick={onScrollToClick.bind(this, "css")}>
            <span class="white-text">CSS</span>
         </a>
      </div>
   </div>

   <dict-config-buttons save-data={saveData}/>

   <script>
      export default {
         state: {
            isLoading: true,
            isLoadingEditor: false,
            isSaving: false,
            editorsInitialized: false,
            isJSValid: null,
            data: {
               useOwnEditor: undefined,
               js: "",
               css: ""
            }
         },

         onMounted() {
            this.store.loadDictionaryConfig("editing")
                  .done(response => {
                     this.state.data = response.content
                     if(this.state.data.useOwnEditor){
                        this.loadAndInitEditors()
                     }
                  })
                  .always(response => {
                     this.update({isLoading: false})
                  })
            this.checkJsCodeDebounced = window.debounce(this.checkJSCode, 100)
         },

         onUseOwnEditorClick(evt){
            this.state.data.useOwnEditor = evt.target.checked
            if(this.state.editorsInitialized){
               $("#editors").toggle(this.state.data.useOwnEditor)
            } else {
               this.loadAndInitEditors()
            }
         },

         onLoadExampleClick() {
            this.state.data.js =
`{
   editor: function(options) {
      // options = {
      //   node: the node into which you should render the editor
      //   entry = JSON object representing the entry
      //   readOnly = true if we want the entry to be uneditable
      //   onChange = the method should be called if the data is changed
      //   onValidChange - the method should be called if data state changes from valid to invalid or vice versa
      //   destroy - this method is called when the editor is closed
      // }
      this.options = options
      this.node = $(options.node)
      this.entry = options.entry
      let editorNode = $("<div class='myEditor'><h3>My custom editor</h3></div>").appendTo(this.node)
      this.contentNode = $('<div class="myEditorContentNode"></div>').appendTo(editorNode)
      this.isValid = null
      this._render()
      this._validate()
   },

   getValue: function() {
      return {
         name: "entry",
         value: this.contentNode.find("input.headword").val(),
         children: [{
            name: "partOfSpeech",
            value: this.contentNode.find("input.partOfSpeech").val()
         }]
      }
   },

   update: function(entry) {
      this.entry = entry
      this._render()
      this._validate()
   },

   _render: function() {
      this.contentNode.empty()
      $(\`<label>headword</label>\`).appendTo(this.contentNode)
      $(\`<input class="headword"
            \$\{this.options.readOnly? "disabled" : ""}
            value="\$\{this.entry.value}"/>\`)
            .appendTo(this.contentNode)
            .on("input", this._onInput.bind(this))
            .on("change", this.options.onChange)
      $(\`<label>Part of speech</label>\`).appendTo(this.contentNode)
      $(\`<input class="partOfSpeech"
            \$\{this.options.readOnly? "disabled" : ""}
            value="\$\{window.nvhStore.findElement(e => e.name == "partOfSpeech").value}"/>\`)
            .appendTo(this.contentNode)
            .on("input", this._onInput.bind(this))
            .on("change", this.options.onChange)
   },

   _onInput: function() {
      this._validate()
   },

   _validate: function() {
      let wasValid = this.isValid
      this.isValid = this.contentNode.find("input.headword").val() !== ""
            && this.contentNode.find("input.partOfSpeech").val() !== ""
      if (wasValid != this.isValid) {
         this.options.onValidChange(this.isValid)
      }
   }
}`

            this.state.data.css =
`.myEditor{
   padding: 0 30px
}
.myEditor headword{
   font-size: 1.25em
}`
            this.editorJS.dispatch({changes: {from: 0, to: this.editorJS.state.doc.length, insert: this.state.data.js}})
            this.editorCSS.dispatch({changes: {from: 0, to: this.editorCSS.state.doc.length,insert: this.state.data.css}})
            this.checkJSCode()
         },

         onJSCodeUpdate(){
            this.state.data.js = this.editorJS.state.doc.toString()
            this.checkJsCodeDebounced()
         },

         onCSSCodeUpdate(){
            this.state.data.css = this.editorCSS.state.doc.toString()
         },

         onKeyDown(evt){
            if(evt.keyCode == 83 && (evt.ctrlKey || evt.metaKey)){
               evt.preventDefault()
               if(this.state.isJSValid){
                  this.saveData()
               } else {
                  M.toast({html: "Invalid code"})
               }
            }
         },

         onShowEditorHelpClick(){
            window.modal.open({
               title: "Custom editor",
               tag: "raw-html",
               props: {
                  content: `Your custom editor should be JavaScript object with these functions:<br>
                  <b class="monospace">editor(options)</b><br>
                  <div class="pl-4">
                     Options is object with following keys:<br>
                     <div class="pl-4">
                        node: jQuery object of the root node to which editor should be attached.<br>
                        entry: JSON representation of the entry<br>
                        readOnly: true/false <br>
                        onChange: method to be called every time the entry changes<br>
                        onValidChange: method to be called every time the entry valid status changes (entry is in valid or invalid state)<br><br>
                     </div>
                  </div>
                  <b class="monospace">update(entry)</b><br>
                  <div class="pl-4">
                     Redraw the editor after data change (e.g. user navigates to another entry, uses undo/redo commands...).<br><br>
                  </div>
                  <b class="monospace">getValue()</b>
                  <div class="pl-4">
                     Returns JSON representation of the actual state of the entry.<br>
      <pre>
      {
         name: "entry",
         value: "",
         children: [{
            name: "headword",
            value: ""
         }]
      }</pre>
                  </div>`
               }
            })
         },

         onScrollToClick(section){
            $([document.documentElement, document.body]).animate({
               scrollTop: $(`#title_${section}`).offset().top
            }, 400);
         },

         loadAndInitEditors(){
            if(this.state.isLoadingEditor){
               return
            }
            this.update({isLoadingEditor: true})
            window.loadScript("bundle.codemirror.js", () => {
               this.update({
                  isLoadingEditor: false,
                  editorsInitialized: true,
               })
               this.editorJS = new window.CodeMirror.EditorView({
                  extensions: [window.CodeMirror.basicSetup,
                        window.CodeMirror.javascript(),
                        window.CodeMirror.EditorView.updateListener.of((v) => {
                           v.viewportChanged && this.onJSCodeUpdate()
                        })],
                  parent: document.getElementById("editorJS")
               })
               this.editorCSS = new window.CodeMirror.EditorView({
                  extensions: [window.CodeMirror.basicSetup,
                        window.CodeMirror.css(),
                        window.CodeMirror.EditorView.updateListener.of((v) => {
                           v.viewportChanged && this.onCSSCodeUpdate()
                        })],
                  parent: document.getElementById("editorCSS")
               })
               $("#editors").show()
               this.editorJS.dispatch({changes: {from: 0,insert: this.state.data.js}})
               this.editorCSS.dispatch({changes: {from: 0,insert: this.state.data.css}})
               this.state.data.js && this.checkJSCode()
               this.editorJS.focus()
            })
         },

         getConfigData() {
            return Object.assign({
               _version: window.LEXONOMY_VERSION
            }, this.state.data)
         },

         checkJSCode(){
            let isValid = false
            if(this.state.data.js){
               let err = ""
               try{
                  let editorFn = new Function("return " + this.state.data.js)()
                  ;["editor", "getValue", "update"].forEach(fnName => {
                     if(typeof editorFn[fnName] != "function"){
                        throw `Missing ${fnName}() function.`
                     }
                  })
                  isValid = true
               } catch(e){
                  err = e.toString().split('\n')[0]
               }
               $("#codeStatus .codeStatusMessage").html(isValid ? `<b class="green-text">valid</b>` : `<b class="red-text">${err}</b>`)
               this.state.isJSValid = isValid
            } else {
               $("#codeStatus .codeStatusMessage").empty()
            }
            $("primary-button .submitButton").toggleClass("disabled", !isValid)
         },

         saveData() {
            this.update({isSaving: true})
            this.store.updateDictionaryConfig("editing", this.getConfigData())
                  .always(() => this.update({isSaving: false}))
         }
      }
   </script>

   <style type="scss">
      #codeStatus{
         position: sticky;
         bottom: 0px;
         right: 1px;
         left: 1px;
         background-color: #dfdfdf;
         padding: 3px 8px;
         margin-bottom: 5px;
         align-items: center;
      }
      .fixed-action-btn{
         span{
            font-size: 20px;
            line-height: 56px;
         }
      }
   </style>
</dict-config-editing>
