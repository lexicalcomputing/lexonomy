<dict-config-subbing>
   <dict-config-nav dictId={ dictId } dictTitle={ props.dictDetails.title } configId={ configId } configTitle={ configTitle }/>
   <h3>Subentries</h3>
   <div if={isLoading} class="center-align grey-text">
      <h3>Loading elements...</h3>
   </div>
   <template if={!isLoading}>
      <div>
         <label>
            Selected subentries
         </label>
         <div if={!configData.elements.length} class="grey-text">
            <i>no subentry element selected</i>
         </div>
         <div if={configData.elements.length}>
            <div each={ element in configData.elements } class="chip">
               { element }
               <i class="close material-icons" onclick={onRemoveElementClick.bind(this, element)}>close</i>
            </div>
            <br>
         </div>
         <br>
      </div>
      <template if={selectOptions.length}>
         <label for="new-element">Add subentry element</label>
         <div class="input-field">
            <div class="buttons" style="max-width: 500px;">
               <select id="new-element">
               </select>
               <a class="btn" onclick={ doAddEl } style="margin-top: 4px;">
                  add
                  <i class="material-icons right">add</i>
               </a>
            </div>
            <span class="helper-text">Elements listed here function as subentries which can be shared by multiple entries.</span>
         </div>
      </template>
   </template>
   <br><br>
   <dict-config-buttons save-data={saveData} dict-id={dictId}></dict-config-buttons>

   <script>
      export default {
         isLoading: true,
         dictId: '',
         configId: '',
         configTitle: 'Subentries',
         configData: {elements:[]},

         onRemoveElementClick(el, evt) {
            evt.stopPropagation()
            this.configData.elements = this.configData.elements.filter(val => val != el);
            this.update()
         },

         doAddEl(event) {
            this.configData.elements.push($('#new-element').val());
            this.update();
         },

         onMounted() {
            this.dictId = this.props.dictId;
            this.configId = this.props.configId;
            this.props.loadDictDetail();
            this.fillConfigForm();
         },

         onBeforeUpdate(){
            this.selectOptions = Object.keys(this.props.dictConfigs.xema.elements).filter(key => {
               return !this.configData.elements.includes(key)
            })
         },

         onUpdated() {
            if (this.props.dictConfigs.xema && this.props.dictConfigs.xema.elements) {
               var $select = $('select')
               if(this.selectOptions.length && $select.length){
                  var instance = M.FormSelect.getInstance($select);
                  instance && instance.destroy()
                  $select.empty()
                  this.selectOptions.forEach(key => {
                     $('#new-element').append('<option value="' + key + '">' + key + '</option>');
                  });
                  $select.formSelect();
               }
            }
         },

         async fillConfigForm() {
            this.props.loadConfigData(this.configId).then((response)=>{
               this.isLoading = false;
               this.configData = {elements: Object.keys(response)}
               this.update();
            });
         },

         saveData() {
            let data = {}
            this.configData.elements.forEach(el => {
               data[el] = {}
            })
            $('#submit_button').html('Saving...');
            this.props.saveConfigData(this.configId, data);
         }
      }
   </script>

</dict-config-subbing>
